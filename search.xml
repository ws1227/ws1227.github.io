<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Swift字符串常用操作]]></title>
      <url>%2F2017-03-28-Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html</url>
      <content type="text"><![CDATA[swift 中关于取子串有4 个方法 str.index(after: String.Index)str.index(before: String.Index)str.index(String.Index, offsetBy: String.IndexDistance)str.index(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index) 分别是什么, 该如何使用?下面来看看本例中, 我们创建一个字符串”Hello, playground” , 如下 var str = “Hello, playground” 字符索引 startIndex 和 endIndex startIndex 是第一个字符的索引, 也就是endIndex 是最后一个字符索引 +1// characterstr[str.startIndex] // Hstr[str.endIndex] // error: after last character// rangelet range = str.startIndex ..&lt; str.endIndexstr[range] // “Hello, playground”afterindex(after: String.Index)after 指向给定索引后面的一个索引(类似与 + 1)// characterlet index = str.index(after: str.startIndex)str[index] // “e”// rangelet range = str.index(after: str.startIndex)..&lt;str.endIndexstr[range] // “ello, playground”beforeindex(before: String.Index)before 指向给定索引之前的一个索引(类似与 - 1)// characterlet index = str.index(before: str.endIndex)str[index] // d// rangelet range = str.startIndex ..&lt; str.index(before: str.endIndex)str[range] // Hello, playgrounoffsetByindex(String.Index, offsetBy: String.IndexDistance)offsetBy 的值可以为正或是负, 正则表示向后, 负则相反.别被offsetBy 的 String.IndexDistance 类型吓到, 本身其实是一个 Int.(类似于+n 和 -n)// characterlet index = str.index(str.startIndex, offsetBy: 7)str[index] // p// rangelet start = str.index(str.startIndex, offsetBy: 7)let end = str.index(str.endIndex, offsetBy: -6)let range = start ..&lt; endstr[range] // playlimitedByindex(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index)limitedBy 在 offset 过大导致溢出错误的时候很有用.这个返回值是一个可选值, 如果 offsetBy 超过了 limitBy, 则返回 nil.// characterif let index = str.index(str.startIndex, offsetBy: 7, limitedBy: str.endIndex) {str[index] // p}上面这段代码中如果offset 设置为 77, 返回值就是 nil, if 中的代码就会跳过所以如果你要取子串的正确姿势是什么?取某个位置之后的所有字符str.substring(from: str.index(str.startIndex, offsetBy: 7)) // playground取倒数某个位置之后的所有字符str.substring(from: str.index(str.endIndex, offsetBy: -10)) //playground取某个位置之前的所有字符str.substring(to: str.index(str.startIndex, offsetBy: 5)) //Hello取倒数某个位置之前的所有字符str.substring(to: str.index(str.endIndex, offsetBy: -12)) //Hello取中间的某个字符串str.substring(with: str.index(str.startIndex, offsetBy: 7) ..&lt; str.index(str.endIndex, offsetBy: -6)) // play]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F2017-03-16-Hexo%E9%85%8D%E5%90%88github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D.html</url>
      <content type="text"><![CDATA[swift 中关于取子串有4 个方法 str.index(after: String.Index)str.index(before: String.Index)str.index(String.Index, offsetBy: String.IndexDistance)str.index(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index) 分别是什么, 该如何使用?下面来看看本例中, 我们创建一个字符串”Hello, playground” , 如下 var str = “Hello, playground” 字符索引startIndex 和 endIndexstartIndex 是第一个字符的索引, 也就是endIndex 是最后一个字符索引 +1// characterstr[str.startIndex] // Hstr[str.endIndex] // error: after last character// rangelet range = str.startIndex ..&lt; str.endIndexstr[range] // “Hello, playground”afterindex(after: String.Index)after 指向给定索引后面的一个索引(类似与 + 1)// characterlet index = str.index(after: str.startIndex)str[index] // “e”// rangelet range = str.index(after: str.startIndex)..&lt;str.endIndexstr[range] // “ello, playground”beforeindex(before: String.Index)before 指向给定索引之前的一个索引(类似与 - 1)// characterlet index = str.index(before: str.endIndex)str[index] // d// rangelet range = str.startIndex ..&lt; str.index(before: str.endIndex)str[range] // Hello, playgrounoffsetByindex(String.Index, offsetBy: String.IndexDistance)offsetBy 的值可以为正或是负, 正则表示向后, 负则相反.别被offsetBy 的 String.IndexDistance 类型吓到, 本身其实是一个 Int.(类似于+n 和 -n)// characterlet index = str.index(str.startIndex, offsetBy: 7)str[index] // p// rangelet start = str.index(str.startIndex, offsetBy: 7)let end = str.index(str.endIndex, offsetBy: -6)let range = start ..&lt; endstr[range] // playlimitedByindex(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index)limitedBy 在 offset 过大导致溢出错误的时候很有用.这个返回值是一个可选值, 如果 offsetBy 超过了 limitBy, 则返回 nil.// characterif let index = str.index(str.startIndex, offsetBy: 7, limitedBy: str.endIndex) { str[index] // p}上面这段代码中如果offset 设置为 77, 返回值就是 nil, if 中的代码就会跳过所以如果你要取子串的正确姿势是什么?取某个位置之后的所有字符str.substring(from: str.index(str.startIndex, offsetBy: 7)) // playground取倒数某个位置之后的所有字符str.substring(from: str.index(str.endIndex, offsetBy: -10)) //playground取某个位置之前的所有字符str.substring(to: str.index(str.startIndex, offsetBy: 5)) //Hello取倒数某个位置之前的所有字符str.substring(to: str.index(str.endIndex, offsetBy: -12)) //Hello取中间的某个字符串str.substring(with: str.index(str.startIndex, offsetBy: 7) ..&lt; str.index(str.endIndex, offsetBy: -6)) // play]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017-03-15-hello-world.html</url>
      <content type="text"><![CDATA[新的一片天]]></content>
    </entry>

    
  
  
</search>
