<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS线程安全篇]]></title>
      <url>%2F2017-05-17-iOS%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%AF%87.html</url>
      <content type="text"><![CDATA[一、前言前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。二、介绍与使用2.1、@synchronizedNSObject&nbsp;obj&nbsp;=&nbsp;[[NSObject&nbsp;alloc]&nbsp;init];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;@synchronized(obj)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;开始”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;结束”);&nbsp;&nbsp;&nbsp;&nbsp;}});dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;sleep(1);&nbsp;&nbsp;&nbsp;&nbsp;@synchronized(obj)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作2”);&nbsp;&nbsp;&nbsp;&nbsp;}});@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。上面结果的执行结果为：2016-06-29&nbsp;20:48:35.747&nbsp;SafeMultiThread[35945:580107]&nbsp;需要线程同步的操作1&nbsp;开始2016-06-29&nbsp;20:48:38.748&nbsp;SafeMultiThread[35945:580107]&nbsp;需要线程同步的操作1&nbsp;结束2016-06-29&nbsp;20:48:38.749&nbsp;SafeMultiThread[35945:580118]&nbsp;需要线程同步的操作22.2、dispatch_semaphoredispatch_semaphore_t&nbsp;signal&nbsp;=&nbsp;dispatch_semaphore_create(1);dispatch_time_t&nbsp;overTime&nbsp;=&nbsp;dispatch_time(DISPATCH_TIME_NOW,&nbsp;3&nbsp;&nbsp;NSEC_PER_SEC);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_wait(signal,&nbsp;overTime);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;开始”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;结束”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_signal(signal);});dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_wait(signal,&nbsp;overTime);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作2”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_signal(signal);});dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。（1）dispatch_semaphore_create的声明为：dispatch_semaphore_t&nbsp;dispatch_semaphore_create(long&nbsp;value);传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。（2）dispatch_semaphore_signal的声明为：long&nbsp;dispatch_semaphore_signal(dispatch_semaphore_t&nbsp;dsema);这个函数会使传入的信号量dsema的值加1；(3) dispatch_semaphore_wait的声明为：long&nbsp;dispatch_semaphore_wait(dispatch_semaphore_t&nbsp;dsema,&nbsp;dispatch_time_t&nbsp;timeout);这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。如上的代码，如果超时时间overTime设置成&gt;2，可完成同步操作。如果overTime上面代码的执行结果为：2016-06-29&nbsp;20:47:52.324&nbsp;SafeMultiThread[35945:579032]&nbsp;需要线程同步的操作1&nbsp;开始2016-06-29&nbsp;20:47:55.325&nbsp;SafeMultiThread[35945:579032]&nbsp;需要线程同步的操作1&nbsp;结束2016-06-29&nbsp;20:47:55.326&nbsp;SafeMultiThread[35945:579033]&nbsp;需要线程同步的操作2如果把超时时间设置为2016-06-30&nbsp;18:53:24.049&nbsp;SafeMultiThread[30834:434334]&nbsp;需要线程同步的操作1&nbsp;开始2016-06-30&nbsp;18:53:25.554&nbsp;SafeMultiThread[30834:434332]&nbsp;需要线程同步的操作22016-06-30&nbsp;18:53:26.054&nbsp;SafeMultiThread[30834:434334]&nbsp;需要线程同步的操作1&nbsp;结束2.3、NSLockNSLock&nbsp;lock&nbsp;=&nbsp;[[NSLock&nbsp;alloc]&nbsp;init];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;//[lock&nbsp;lock];&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;lockBeforeDate:[NSDate&nbsp;date]];&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;开始”);&nbsp;&nbsp;&nbsp;&nbsp;sleep(2);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;结束”);&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;unlock];});dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;sleep(1);&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;([lock&nbsp;tryLock])&nbsp;{//尝试获取锁，如果获取不到返回NO，不会阻塞该线程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”锁可用的操作”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;unlock];&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”锁不可用的操作”);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;NSDate&nbsp;date&nbsp;=&nbsp;[[NSDate&nbsp;alloc]&nbsp;initWithTimeIntervalSinceNow:3];&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;([lock&nbsp;lockBeforeDate:date])&nbsp;{//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程,&nbsp;返回NO,不会阻塞该线程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”没有超时，获得锁”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;unlock];&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”超时，没有获得锁”);&nbsp;&nbsp;&nbsp;&nbsp;}});NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。上面代码的执行结果为：2016-06-29&nbsp;20:45:08.864&nbsp;SafeMultiThread[35911:575795]&nbsp;需要线程同步的操作1&nbsp;开始2016-06-29&nbsp;20:45:09.869&nbsp;SafeMultiThread[35911:575781]&nbsp;锁不可用的操作2016-06-29&nbsp;20:45:10.869&nbsp;SafeMultiThread[35911:575795]&nbsp;需要线程同步的操作1&nbsp;结束2016-06-29&nbsp;20:45:10.870&nbsp;SafeMultiThread[35911:575781]&nbsp;没有超时，获得锁源码定义如下：@protocol&nbsp;NSLocking-&nbsp;(void)lock;-&nbsp;(void)unlock;@end@interface&nbsp;NSLock&nbsp;:&nbsp;NSObject&nbsp;&nbsp;{@private&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;_priv;}-&nbsp;(BOOL)tryLock;-&nbsp;(BOOL)lockBeforeDate:(NSDate&nbsp;)limit;@property&nbsp;(nullable,&nbsp;copy)&nbsp;NSString&nbsp;name&nbsp;NS_AVAILABLE(10_5,&nbsp;2_0);@end2.4、NSRecursiveLock递归锁//NSLock&nbsp;lock&nbsp;=&nbsp;[[NSLock&nbsp;alloc]&nbsp;init];NSRecursiveLock&nbsp;*lock&nbsp;=&nbsp;[[NSRecursiveLock&nbsp;alloc]&nbsp;init];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;(^RecursiveMethod)(int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RecursiveMethod&nbsp;=&nbsp;^(int&nbsp;value)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;lock];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(value&nbsp;&gt;&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”value&nbsp;=&nbsp;%d”,&nbsp;value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RecursiveMethod(value&nbsp;-&nbsp;1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;unlock];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RecursiveMethod(5);});]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C Runtime 1小时入门教程]]></title>
      <url>%2F2017-05-15-Objective-C-Runtime-1%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html</url>
      <content type="text"><![CDATA[一、前言： 如果你没有Objective-C基础，请学习了基础的iOS开发再来，这个1小时是给有一定iOS基础的童鞋的。如果你是大牛或者你感觉Objective-C Runtime太简单不用1小时学习的，也请您绕道，这或许只是我的私人笔记了。请跟着教程“一步步来”，请不要大概地扫两眼就说看不懂——以这种态度写成什么样你也看不懂。这是1小时入门教程，请不要试图在1分钟内入门！二、本文目标：1小时让你知道什么是Objective-C Runtime，并对它有一定的基本了解，可以在开发过程中运用自如。三、Objective-C Runtime到底是什么东西？简而言之，Objective-C Runtime是一个将C语言转化为面向对象语言的扩展。我们将C++和Objective进行对比，虽然C++和Objective-C都是在C的基础上加入面向对象的特性扩充而成的程序设计语言，但二者实现的机制差异很大。C++是基于静态类型，而Objective-C是基于动态运行时类型。也就是说用C++编写的程序编译时就直接编译成了可令机器读懂的机器语言；用Objective-C编写的程序不能直接编译成可令机器读懂的机器语言，而是在程序运行的时候，通过Runtime把程序转为可令机器读懂的机器语言。也就是说用C++编写的程序通过编译器直接把函数地址硬编码进入可执行文件；而Objective-C无法通过编译器直接把函数地址硬编码进入可执行文件，而是在程序运行的时候，利用Runtime根据条件判断作出决定。函数标识与函数过程的真正内容之间的关联可以动态修改。Runtime是Objective不可缺少的重要一部分。传送门-&gt;runtime源码四、Objective-C的元素认知4.1 id和Class打开/Public Headers/objc.h文件可以看到如下定义：#if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class.typedef struct objc_class Class;/// Represents an instance of a class.struct objc_object {Class isa OBJC_ISA_AVAILABILITY;};/// A pointer to an instance of a class.typedef struct objc_object id;#endifClass是一个指向objc_class结构体的指针，而id是一个指向objc_object结构体的指针，其中的isa是一个指向objc_class结构体的指针。其中的id就是我们所说的对象，Class就是我们所说的类。打开/Public Headers/runtime.h文件objc_class的定义如下：typedef struct objc_class Class;struct objc_class {Class isa OBJC_ISA_AVAILABILITY; // metaclass#if !OBJC2Class super_class OBJC2_UNAVAILABLE; // 父类const char name OBJC2_UNAVAILABLE; // 类名long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取long info OBJC2_UNAVAILABLE; // 类信息，供运行时期使用的一些位标识，如CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小（包括从父类继承下来的实例变量）struct objc_ivar_list ivars OBJC2_UNAVAILABLE; // 该类的成员变量地址列表struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法地址列表，与 info 的一些标志位有关，如CLS_CLASS (0x1L)，则存储实例方法，如CLS_META (0x2L)，则存储类方法;struct objc_cache cache OBJC2_UNAVAILABLE; // 缓存最近使用的方法地址，用于提升效率；struct objc_protocol_list protocols OBJC2_UNAVAILABLE; // 存储该类声明遵守的协议的列表#endif}/ Use Class instead of struct objc_class * /由以上代码可见，类与对象的区别就是类比对象多了很多特征成员，类也可以当做一个objc_object来对待，也就是说类和对象都是对象，分别称作类对象（class object）和实例对象（instance object），这样我们就可以区别对象和类了。isa：objc_object（实例对象）中isa指针指向的类结构称为class（也就是该对象所属的类）其中存放着普通成员变量与动态方法（“-”开头的方法）；此处isa指针指向的类结构称为metaclass，其中存放着static类型的成员变量与static类型的方法（“+”开头的方法）。super_class： 指向该类的父类的指针，如果该类是根类（如NSObject或NSProxy），那么super_class就为nil。类与对象的继承层次关系如图（图片源自网络）：所有的metaclass中isa指针都是指向根metaclass，而根metaclass则指向自身。根metaclass是通过继承根类产生的，与根class结构体成员一致，不同的是根metaclass的isa指针指向自身。4.2 SELSEL是selector在Objective-C中的表示类型。selector可以理解为区别方法的ID。typedef struct objc_selector SEL;objc_selector的定义如下：struct objc_selector {char name; OBJC2_UNAVAILABLE;// 名称char types; OBJC2_UNAVAILABLE;// 类型};name和types都是char类型。4.3 IMP终于到IMP了，它在objc.h中得定义如下：typedef id (IMP)(id, SEL, …);IMP是“implementation”的缩写，它是由编译器生成的一个函数指针。当你发起一个消息后（下文介绍），这个函数指针决定了最终执行哪段代码。4.4 MethodMethod代表类中的某个方法的类型。typedef struct objc_method Method;objc_method的定义如下：struct objc_method {SEL method_name OBJC2_UNAVAILABLE; // 方法名char method_types OBJC2_UNAVAILABLE; // 方法类型IMP method_imp OBJC2_UNAVAILABLE; // 方法实现}方法名method_name类型为SEL，上文提到过。方法类型method_types是一个char指针，存储着方法的参数类型和返回值类型。方法实现method_imp的类型为IMP，上文提到过。4.5 IvarIvar代表类中实例变量的类型typedef struct objc_ivar Ivar;objc_ivar的定义如下：struct objc_ivar {char ivar_name OBJC2_UNAVAILABLE; // 变量名char ivar_type OBJC2_UNAVAILABLE; // 变量类型int ivar_offset OBJC2_UNAVAILABLE; // 基地址偏移字节#ifdef LP64int space OBJC2_UNAVAILABLE; // 占用空间#endif}4.6 objc_property_tobjc_property_t是属性，它的定义如下：typedef struct objc_property objc_property_t;objc_property是内置的类型，与之关联的还有一个objc_property_attribute_t，它是属性的attribute，也就是其实是对属性的详细描述，包括属性名称、属性编码类型、原子类型/非原子类型等。它的定义如下：typedef struct {const char name; // 名称const char value; // 值（通常是空的）} objc_property_attribute_t;4.7 CacheCatch的定义如下：typedef struct objc_cache Cacheobjc_cache的定义如下：struct objc_cache {unsigned int mask OBJC2_UNAVAILABLE;unsigned int occupied OBJC2_UNAVAILABLE;Method buckets[1] OBJC2_UNAVAILABLE;};mask: 指定分配cache buckets的总数。在方法查找中，Runtime使用这个字段确定数组的索引位置。occupied: 实际占用cache buckets的总数。buckets: 指定Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。objc_msgSend（下文讲解）每调用一次方法后，就会把该方法缓存到cache列表中，下次的时候，就直接优先从cache列表中寻找，如果cache没有，才从methodLists中查找方法。4.8 Catagory这个就是我们平时所说的类别了，很熟悉吧。它可以动态的为已存在的类添加新的方法。它的定义如下：typedef struct objc_category Category;objc_category的定义如下：struct objc_category {char category_name OBJC2_UNAVAILABLE; // 类别名称char class_name OBJC2_UNAVAILABLE; // 类名struct objc_method_list instance_methods OBJC2_UNAVAILABLE; // 实例方法列表struct objc_method_list class_methods OBJC2_UNAVAILABLE; // 类方法列表struct objc_protocol_list protocols OBJC2_UNAVAILABLE; // 协议列表}因为是入门，以上就列举这些吧！五、Objective-C的消息传递5.1 基本消息传递在面向对象编程中，对象调用方法叫做发送消息。在编译时，程序的源代码就会从对象发送消息转换成Runtime的objc_msgSend函数调用。例如某实例变量receiver实现某一个方法oneMethod[receiver oneMethod];Runtime会将其转成类似这样的代码objc_msgSend(receiver, selector);具体会转换成什么代码呢？Runtime会根据类型自动转换成下列某一个函数：objc_msgSend:普通的消息都会通过该函数发送objc_msgSend_stret:消息中有数据结构作为返回值（不是简单值）时，通过此函数发送和接收返回值objc_msgSendSuper:和objc_msgSend类似，这里把消息发送给父类的实例objc_msgSendSuper_stret:和objc_msgSend_stret类似，这里把消息发送给父类的实例并接收返回值当消息被发送到实例对象时，是如图所示处理的（图片源自网络）：objc_msgSend函数的调用过程：第一步：检测这个selector是不是要忽略的。第二步：检测这个target是不是nil对象。nil对象发送任何一个消息都会被忽略掉。第三步：1.调用实例方法时，它会首先在自身isa指针指向的类（class）methodLists中查找该方法，如果找不到则会通过class的super_class指针找到父类的类对象结构体，然后从methodLists中查找该方法，如果仍然找不到，则继续通过super_class向上一级父类结构体中查找，直至根class；2.当我们调用某个某个类方法时，它会首先通过自己的isa指针找到metaclass，并从其中methodLists中查找该类方法，如果找不到则会通过metaclass的super_class指针找到父类的metaclass对象结构体，然后从methodLists中查找该方法，如果仍然找不到，则继续通过super_class向上一级父类结构体中查找，直至根metaclass；第四部：前三部都找不到就会进入动态方法解析(看下文)。5.2 消息动态解析动态解析流程图（图片来自网络）：请参照图片品味以下步骤（实例请看下文《6.6 苍老师的唱歌篇》）：第一步：通过resolveInstanceMethod：方法决定是否动态添加方法。如果返回Yes则通过class_addMethod动态添加方法，消息得到处理，结束；如果返回No，则进入下一步；第二步：这步会进入forwardingTargetForSelector:方法，用于指定备选对象响应这个selector，不能指定为self。如果返回某个对象则会调用对象的方法，结束。如果返回nil，则进入第三部；第三部：这步我们要通过methodSignatureForSelector:方法签名，如果返回nil，则消息无法处理。如果返回methodSignature，则进入下一步；第四部：这步调用forwardInvocation：方法，我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果失败，则进入doesNotRecognizeSelector方法，若我们没有实现这个方法，那么就会crash。到这里大家可能晕乎乎的，下面看实战篇吧！苍老师必须让你懂！六、Runtime实战请大家放心，以下所有实战篇，在最后都会分享Demo给大家！6.1 苍老师问好篇苍老师见到我们广大的粉丝们，第一反应当然是：大家好！#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif// 自定义一个方法void sayFunction(id self, SEL _cmd, id some) {NSLog(@”%@岁的%@说：%@”, object_getIvar(self, class_getInstanceVariable([self class], “_age”)),[self valueForKey:@”name”],some);}int main(int argc, const char argv[]) {@autoreleasepool {// 动态创建对象 创建一个Person 继承自 NSObject类Class People = objc_allocateClassPair([NSObject class], “Person”, 0);// 为该类添加NSString _name成员变量class_addIvar(People, “_name”, sizeof(NSString), log2(sizeof(NSString)), @encode(NSString));// 为该类添加int _age成员变量class_addIvar(People, “_age”, sizeof(int), sizeof(int), @encode(int));// 注册方法名为say的方法SEL s = sel_registerName(“say:”);// 为该类增加名为say的方法class_addMethod(People, s, (IMP)sayFunction, “v@:@”);// 注册该类objc_registerClassPair(People);// 创建一个类的实例id peopleInstance = [[People alloc] init];// KVC 动态改变 对象peopleInstance 中的实例变量[peopleInstance setValue:@”苍老师” forKey:@”name”];// 从类中获取成员变量IvarIvar ageIvar = class_getInstanceVariable(People, “_age”);// 为peopleInstance的成员变量赋值object_setIvar(peopleInstance, ageIvar, @18);// 调用 peopleInstance 对象中的 s 方法选择器对于的方法// objc_msgSend(peopleInstance, s, @”大家好!”); // 这样写也可以，请看我博客说明((void ()(id, SEL, id))objc_msgSend)(peopleInstance, s, @”大家好”);peopleInstance = nil; //当People类或者它的子类的实例还存在，则不能调用objc_disposeClassPair这个方法；因此这里要先销毁实例对象后才能销毁类；// 销毁类objc_disposeClassPair(People);}return 0;}最后的结果是：18岁的苍老师说：大家好！在使用objc_msgSend(peopleInstance, s, @”大家好!”);默认会出现以下错误：objc_msgSend()报错Too many arguments to function call ,expected 0,have3直接通过objc_msgSend(self, setter, value)是报错，说参数过多。请这样解决：Build Setting&#8211;&gt; Apple LLVM 7.0 &#8211; Preprocessing&#8211;&gt; Enable Strict Checking of objc_msgSend Calls 改为 NO当然你也可以这样写(推荐)：((void ()(id, SEL, id))objc_msgSend)(peopleInstance, s, @”大家好”);强制转换objc_msgSend函数类型为带三个参数且返回值为void函数，然后才能传三个参数。此实战内容是，动态创建一个类，并创建成员变量和方法，最后赋值成员变量并发送消息。其中成员变量的赋值使用了KVC和object_setIvar函数两种方式，这些东西大家举一反三就可以了。Demo传送门-&gt;6.1苍老师问好篇Demo6.2 苍老师的特征篇苍老师在大家心目中应该有很多特征吧，下面我们通过代码来获取苍老师的特征。People.h文件@interface People : NSObject{NSString _occupation;NSString _nationality;}@property (nonatomic, copy) NSString name;@property (nonatomic) NSUInteger age;- (NSDictionary )allProperties;- (NSDictionary )allIvars;- (NSDictionary )allMethods;@endPeople.m文件#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People- (NSDictionary )allProperties{unsigned int count = 0;// 获取类的所有属性，如果没有属性count就为0objc_property_t properties = class_copyPropertyList([self class], &amp;count);NSMutableDictionary resultDict = [@{} mutableCopy];for (NSUInteger i = 0; i &lt; count; i ++) {// 获取属性的名称和值const char propertyName = property_getName(properties[i]);NSString name = [NSString stringWithUTF8String:propertyName];id propertyValue = [self valueForKey:name];if (propertyValue) {resultDict[name] = propertyValue;} else {resultDict[name] = @”字典的key对应的value不能为nil哦！”;}}// 这里properties是一个数组指针，我们需要使用free函数来释放内存。free(properties);return resultDict;}- (NSDictionary )allIvars{unsigned int count = 0;NSMutableDictionary resultDict = [@{} mutableCopy];Ivar ivars = class_copyIvarList([self class], &amp;count);for (NSUInteger i = 0; i &lt; count; i ++) {const char varName = ivar_getName(ivars[i]);NSString name = [NSString stringWithUTF8String:varName];id varValue = [self valueForKey:name];if (varValue) {resultDict[name] = varValue;} else {resultDict[name] = @”字典的key对应的value不能为nil哦！”;}}free(ivars);return resultDict;}- (NSDictionary )allMethods{unsigned int count = 0;NSMutableDictionary resultDict = [@{} mutableCopy];// 获取类的所有方法，如果没有方法count就为0Method methods = class_copyMethodList([self class], &amp;count);for (NSUInteger i = 0; i &lt; count; i ++) {// 获取方法名称SEL methodSEL = method_getName(methods[i]);const char methodName = sel_getName(methodSEL);NSString name = [NSString stringWithUTF8String:methodName];// 获取方法的参数列表int arguments = method_getNumberOfArguments(methods[i]);resultDict[name] = @(arguments-2);}free(methods);return resultDict;}@end在main.m中运行以下代码int main(int argc, const char argv[]) {@autoreleasepool {People cangTeacher = [[People alloc] init];cangTeacher.name = @”苍井空”;cangTeacher.age = 18;[cangTeacher setValue:@”老师” forKey:@”occupation”];NSDictionary propertyResultDic = [cangTeacher allProperties];for (NSString propertyName in propertyResultDic.allKeys) {NSLog(@”propertyName:%@, propertyValue:%@”,propertyName, propertyResultDic[propertyName]);}NSDictionary ivarResultDic = [cangTeacher allIvars];for (NSString ivarName in ivarResultDic.allKeys) {NSLog(@”ivarName:%@, ivarValue:%@”,ivarName, ivarResultDic[ivarName]);}NSDictionary methodResultDic = [cangTeacher allMethods];for (NSString methodName in methodResultDic.allKeys) {NSLog(@”methodName:%@, argumentsCount:%@”, methodName, methodResultDic[methodName]);}}return 0;}最后的输出结果如下：是不是有点失望，我没有加一些特殊的技能，留给下文了。此实战内容是通过苍老师的一些特征学习：如何获取对象所有的属性名称和属性值、获取对象所有成员变量名称和变量值、获取对象所有的方法名和方法参数数量。Demo传送门-&gt;6.2苍老师的特征篇Demo6.3 苍老师增加新技能篇苍老师要通过Category和Associated Objects增加技能了，快看！创建People+Associated.h文件如下：#import “People.h”typedef void (^CodingCallBack)();@interface People (Associated)@property (nonatomic, strong) NSNumber associatedBust; // 胸围@property (nonatomic, copy) CodingCallBack associatedCallBack; // 写代码@endPeople+Associated.m如下:#import “People+Associated.h”#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People (Associated)- (void)setAssociatedBust:(NSNumber )bust{// 设置关联对象objc_setAssociatedObject(self, @selector(associatedBust), bust, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (NSNumber )associatedBust{// 得到关联对象return objc_getAssociatedObject(self, @selector(associatedBust));}- (void)setAssociatedCallBack:(CodingCallBack)callback {objc_setAssociatedObject(self, @selector(associatedCallBack), callback, OBJC_ASSOCIATION_COPY_NONATOMIC);}- (CodingCallBack)associatedCallBack {return objc_getAssociatedObject(self, @selector(associatedCallBack));}@end在main.m中运行以下代码#import “People.h”#import “People+Associated.h”int main(int argc, const char argv[]) {@autoreleasepool {People cangTeacher = [[People alloc] init];cangTeacher.name = @”苍井空”;cangTeacher.age = 18;[cangTeacher setValue:@”老师” forKey:@”occupation”];cangTeacher.associatedBust = @(90);cangTeacher.associatedCallBack = ^(){NSLog(@”苍老师要写代码了！”);};cangTeacher.associatedCallBack();NSDictionary propertyResultDic = [cangTeacher allProperties];for (NSString propertyName in propertyResultDic.allKeys) {NSLog(@”propertyName:%@, propertyValue:%@”,propertyName, propertyResultDic[propertyName]);}NSDictionary methodResultDic = [cangTeacher allMethods];for (NSString methodName in methodResultDic.allKeys) {NSLog(@”methodName:%@, argumentsCount:%@”, methodName, methodResultDic[methodName]);}}return 0;}这次运行结果多出了一个associatedBust（胸围）和一个associatedCallBack（写代码）属性。如图：我们成功的给苍老师添加个一个胸围的属性和一个写代码的回调，但是添加属性没有什么意义，我们平时在开发过成功中用的比较多的就是添加回调了。Demo传送门-&gt;6.3苍老师增加新技能篇Demo6.4 苍老师的资料归档篇苍老师的资料总要整理一下吧！创建People.h#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject &lt;NSCoding&gt;@property (nonatomic, copy) NSString name; // 姓名@property (nonatomic, strong) NSNumber age; // 年龄@property (nonatomic, copy) NSString occupation; // 职业@property (nonatomic, copy) NSString nationality; // 国籍@endPeople.m#import “People.h”#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People- (void)encodeWithCoder:(NSCoder )aCoder {unsigned int count = 0;Ivar ivars = class_copyIvarList([People class], &amp;count);for (NSUInteger i = 0; i &lt; count; i ++) {Ivar ivar = ivars[i];const char name = ivar_getName(ivar);NSString key = [NSString stringWithUTF8String:name];id value = [self valueForKey:key];[aCoder encodeObject:value forKey:key];}free(ivars);}- (id)initWithCoder:(NSCoder )aDecoder {self = [super init];if (self) {unsigned int count = 0;Ivar ivars = class_copyIvarList([People class], &amp;count);for (NSUInteger i = 0; i &lt; count; i ++) {Ivar ivar = ivars[i];const char name = ivar_getName(ivar);NSString key = [NSString stringWithUTF8String:name];id value = [aDecoder decodeObjectForKey:key];[self setValue:value forKey:key];}free(ivars);}return self;}@endDemo传送门-&gt;6.4苍老师的资料归档篇Demo6.5 苍老师的资料转换篇服务器返回了大量苍老师的数据，手机端这边接收后如何去转换呢？当然是要将JSON转换为Model啦！相信平时你们的项目中也用到过这些三方库，下面我们去了解下runtime实现JSON和Model互转。创建People.h#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject@property (nonatomic, copy) NSString name; // 姓名@property (nonatomic, strong) NSNumber age; // 年龄@property (nonatomic, copy) NSString occupation; // 职业@property (nonatomic, copy) NSString nationality; // 国籍// 生成model- (instancetype)initWithDictionary:(NSDictionary )dictionary;// 转换成字典- (NSDictionary )covertToDictionary;@endPeople.m的代码如下：#import “People.h”#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People- (instancetype)initWithDictionary:(NSDictionary )dictionary{self = [super init];if (self) {for (NSString key in dictionary.allKeys) {id value = dictionary[key];SEL setter = [self propertySetterByKey:key];if (setter) {// 这里还可以使用NSInvocation或者method_invoke，不再继续深究了，有兴趣google。((void ()(id, SEL, id))objc_msgSend)(self, setter, value);}}}return self;}- (NSDictionary )covertToDictionary{unsigned int count = 0;objc_property_t properties = class_copyPropertyList([self class], &amp;count);if (count != 0) {NSMutableDictionary resultDict = [@{} mutableCopy];for (NSUInteger i = 0; i &lt; count; i ++) {const void propertyName = property_getName(properties[i]);NSString name = [NSString stringWithUTF8String:propertyName];SEL getter = [self propertyGetterByKey:name];if (getter) {id value = ((id ()(id, SEL))objc_msgSend)(self, getter);if (value) {resultDict[name] = value;} else {resultDict[name] = @”字典的key对应的value不能为nil哦！”;}}}free(properties);return resultDict;}free(properties);return nil;}#pragma mark - private methods// 生成setter方法- (SEL)propertySetterByKey:(NSString )key{// 首字母大写，你懂得NSString propertySetterName = [NSString stringWithFormat:@”set%@:”, key.capitalizedString];SEL setter = NSSelectorFromString(propertySetterName);if ([self respondsToSelector:setter]) {return setter;}return nil;}// 生成getter方法- (SEL)propertyGetterByKey:(NSString )key{SEL getter = NSSelectorFromString(key);if ([self respondsToSelector:getter]) {return getter;}return nil;}@endmain.m中运行以下代码：#import &lt;Foundation/Foundation.h&gt;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import “People.h”int main(int argc, const char argv[]) {@autoreleasepool {NSDictionary dict = @{@”name” : @”苍井空”,@”age” : @18,@”occupation” : @”老师”,@”nationality” : @”日本”};// 字典转模型People cangTeacher = [[People alloc] initWithDictionary:dict];NSLog(@”热烈欢迎，从%@远道而来的%@岁的%@%@”,cangTeacher.nationality,cangTeacher.age,cangTeacher.name,cangTeacher.occupation);// 模型转字典NSDictionary covertedDict = [cangTeacher covertToDictionary];NSLog(@”%@”,covertedDict);}return 0;}最后输出内容如下：相信通过前面的学习，这些代码不用写过多的注释你也可以看懂了，我把假设是网络返回的苍老师的资料转化为了model，然后又将model转回字典。这是一个JSON转Model相互转换的一个思路，大家稍后运行Demo细细品味。Demo传送门-&gt;6.5苍老师的资料转换篇Demo6.6 苍老师的唱歌篇这个实例主要是验证一下上文《5.2 消息动态解析》第一首：添加sing实例方法，但是不提供方法的实现。验证当找不到方法的实现时，动态添加方法。创建People.h#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject@property (nonatomic, copy) NSString name;- (void)sing;@end创建People.m#import “People.h”#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People+ (BOOL)resolveInstanceMethod:(SEL)sel{// 我们没有给People类声明sing方法，我们这里动态添加方法if ([NSStringFromSelector(sel) isEqualToString:@”sing”]) {class_addMethod(self, sel, (IMP)otherSing, “v@:”);return YES;}return [super resolveInstanceMethod:sel];}void otherSing(id self, SEL cmd){NSLog(@”%@ 唱歌啦！”,((People )self).name);}在main.m中运行以下代码：#import &lt;Foundation/Foundation.h&gt;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import “People.h”int main(int argc, const char argv[]) {@autoreleasepool {People cangTeacher = [[People alloc] init];cangTeacher.name = @”苍老师”;[cangTeacher sing];}return 0;}结果如下：我们没有提供苍老师唱歌的方法实现，因此在调用此方法的时候，会调用resolveInstanceMethod方法，我们动态添加了方法。我们也可以返回No，继续向下传递。（此处请返回《5.2 消息动态解析》第一步品味下）Demo传送门-&gt;6.6苍老师唱歌篇(第一首)Demo第二首外面的小鸟在唱歌，但是苍老师的歌声盖过了小鸟，我们只能听到苍老师唱歌了。这里我们不声明sing方法，将调用途中动态更换调用对象。在第一首代码的基础上，创建Bird的modelBird.h#import &lt;Foundation/Foundation.h&gt;@interface Bird : NSObject@property (nonatomic, copy) NSString name;@endBird.m#import “Bird.h”#import “People.h”@implementation Bird// 第一步：我们不动态添加方法，返回NO，进入第二步；+ (BOOL)resolveInstanceMethod:(SEL)sel{return NO;}// 第二部：我们不指定备选对象响应aSelector，进入第三步；- (id)forwardingTargetForSelector:(SEL)aSelector{return nil;}// 第三步：返回方法选择器，然后进入第四部；- (NSMethodSignature )methodSignatureForSelector:(SEL)aSelector{if ([NSStringFromSelector(aSelector) isEqualToString:@”sing”]) {return [NSMethodSignature signatureWithObjCTypes:”v@:”];}return [super methodSignatureForSelector:aSelector];}// 第四部：这步我们修改调用对象- (void)forwardInvocation:(NSInvocation )anInvocation{// 我们改变调用对象为PeoplePeople cangTeacher = [[People alloc] init];cangTeacher.name = @”苍老师”;[anInvocation invokeWithTarget:cangTeacher];}@endmain.m运行代码如下：#import &lt;Foundation/Foundation.h&gt;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import “People.h”#import “Bird.h”int main(int argc, const char argv[]) {@autoreleasepool {Bird bird = [[Bird alloc] init];bird.name = @”小小鸟”;((void ()(id, SEL))objc_msgSend)((id)bird, @selector(sing));}return 0;}运行结果如下：成功更换了对象，把对象更换为苍老师了。（此处请返回《5.2 消息动态解析》品味）Demo传送门-&gt;6.6苍老师唱歌篇(第二首)Demo第三首苍老师不想唱歌想跳舞了。这里我是实现不提供声明，不修改调用对象，但是将sing方法修改为dance方法。创建People.h#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject@endPeople.m#import “People.h”#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People// 第一步：我们不动态添加方法，返回NO，进入第二步；+ (BOOL)resolveInstanceMethod:(SEL)sel{return NO;}// 第二部：我们不指定备选对象响应aSelector，进入第三步；- (id)forwardingTargetForSelector:(SEL)aSelector{return nil;}// 第三步：返回方法选择器，然后进入第四部；- (NSMethodSignature )methodSignatureForSelector:(SEL)aSelector{if ([NSStringFromSelector(aSelector) isEqualToString:@”sing”]) {return [NSMethodSignature signatureWithObjCTypes:”v@:”];}return [super methodSignatureForSelector:aSelector];}// 第四部：这步我们修改调用方法- (void)forwardInvocation:(NSInvocation )anInvocation{[anInvocation setSelector:@selector(dance)];// 这还要指定是哪个对象的方法[anInvocation invokeWithTarget:self];}// 若forwardInvocation没有实现，则会调用此方法- (void)doesNotRecognizeSelector:(SEL)aSelector{NSLog(@”消息无法处理：%@”, NSStringFromSelector(aSelector));}- (void)dance{NSLog(@”跳舞！！！come on！”);}@end在main.m中运行如下代码：#import &lt;Foundation/Foundation.h&gt;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import “People.h”int main(int argc, const char argv[]) {@autoreleasepool {People cangTeacher = [[People alloc] init];((void(*)(id, SEL)) objc_msgSend)((id)cangTeacher, @selector(sing));}return 0;}结果如图：成功更换了方法，苍老师由唱歌改为跳舞了（此处请返回《5.2 消息动态解析》品味）Demo传送门-&gt;6.6苍老师唱歌篇(第三首)Demo总结好吧，我承认我骗了你，当你读到这里你肯定花了不止1小时。都是我的错，不是因为你笨，之所以说1小时是为了让你有信心，有耐心继续下去。读到这里恭喜你已经在iOS开发的道路上又向前了一步！同时我也要感谢以下参考文献以及文章，是他们让我更好的理解了runtime，再次表示感谢！这篇文章断断续续写了将近一周的时间，您可以读到这里就是对我最大的鼓励，谢谢！Demo传送门-&gt;所有的Demo打包下载 原文地址 本文参考文献以及文章：Objective-C Runtime ReferenceObject Model初识Objective-C RuntimeObjective-C RuntimeObjective-C Runtime 运行时之一：类与对象Runtime Message Forwardingruntime模型与字典互转iOS开发之深入探讨runtime机制Objective-C runtime之消息（二）Objective-C runtime之消息转发机制（三）《编写高质量代码：改善Objective-C程序的61个建议》《正则表达式30分钟入门教程》（参考写作方式）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift使用OC框架]]></title>
      <url>%2F2017-05-11-Swift%E4%BD%BF%E7%94%A8OC%E6%A1%86%E6%9E%B6.html</url>
      <content type="text"><![CDATA[Swift使用OC框架 场景一：使用Cocopods导入框架看以前的教程用Cocopods导入框架也要手动设置桥接文件，我最近创建的项目用Cocopods安装的SDWebImage和SVProgressHUD发现xcode会自动生成一个桥接的.h文件名字是Targets-Bridging-Header.h,并且会自动设置路径如图，这个稍后在场景2再继续介绍 用Cocopods导入的OC框架Xcode会自动生成一个文件但是我并不能在本地找到他，看SDWebImage的这个文件如下在使用的过程中直接用import SDWebImage就可以使用 SDWebImage的各种方法了这种由Cocopods导入的框架都会生成这个类似的文件不用在桥接文件有引入头文件类似#import “UIImageView+WebCache.h”. 场景二：没有使用Cocopods或者使用Cocopods手动导入框架没有使用Cocopods就需要自己新建一个桥接文件了当然如果用了Cocopods可以使用Xcode自动生成的就是场景一的那种情况了,下图新建一个桥接文件命名随意这里的图是用别人的真是随意了啊，我建议命名规则可以按照Targets-Bridging-Header.h毕竟这样看起来正规点嘛填好文件名字,选中语言为Objective-C,点击Next 这个时候回出现一个弹框,意思就是 你是否想要配置一个OC桥接文件,选择创建，路径可以按照场景一的图找到就不再上图了。这里强调一个重要设置注意、注意、注意重要的事情说三遍嘛1.选择target（就是左边你的工程target）—— BuildSettings —— search Paths 下的 User Header Search Paths 2.双击后面的空白区域，并且点击“+”号添加一项：并且输入：“$(PODS_ROOT)”（没有引号），选择：recursive（会在相应的目录递归搜索文件）。 这个设置完才可以保证在桥接文件里能够正常引用OC库 一切设置妥当就可以手动拖入OC库了，举个例子我用的Toast 愉快使用OC和Swift的混编吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC中load方法和initialize方法的区别]]></title>
      <url>%2F2017-05-10-OC%E4%B8%ADload%E6%96%B9%E6%B3%95%E5%92%8Cinitialize%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="text"><![CDATA[OC中有两个特殊的类方法，分别是load和initialize。本文总结一下这两个方法的区别于联系、使用场景和注意事项。Demo可以在我的Github上找到——load和initialize，如果觉得有帮助还望点个star以示支持，总结在文章末尾。load顾名思义，load方法在这个文件被程序装载时调用。只要是在Compile Sources中出现的文件总是会被装载，这与这个类是否被用到无关，因此load方法总是在main函数之前调用。调用规则如果一个类实现了load方法，在调用这个方法前会首先调用父类的load方法。而且这个过程是自动完成的，并不需要我们手动实现：// In Parent.m+ (void)load { NSLog(@”Load Class Parent”);}// In Child.m，继承自Parent+ (void)load { NSLog(@”Load Class Child”);}// In Child+load.m，Child类的分类+ (void)load { NSLog(@”Load Class Child+load”);}// 运行结果：/ 2016-02-01 21:28:14.379 load[11789:1435378] Load Class Parent 2016-02-01 21:28:14.380 load[11789:1435378] Load Class Child 2016-02-01 22:28:14.381 load[11789:1435378] Load Class Child+load /如果一个类没有实现load方法，那么就不会调用它父类的load方法，这一点与正常的类继承和方法调用不一样，需要额外注意一下。执行顺序load方法调用时，系统处于脆弱状态，如果调用别的类的方法，且该方法依赖于那个类的load方法进行初始化设置，那么必须确保那个类的load方法已经调用了，比如demo中的这段代码，打印出的字符串就为null： 12345678910// In Child.m+ (void)load &#123; NSLog(@&quot;Load Class Child&quot;); Other *other = [Other new]; [other originalFunc]; // 如果不先调用other的load，下面这行代码就无效，打印出null [Other printName];&#125; load方法的调用顺序其实有迹可循，我们看到demo的项目设置如下：执行顺序在Compile Sources中，文件的排放顺序就是其装载顺序，自然也就是load方法调用的顺序。这一点也证明了load方法中会自动调用父类的方法，因为在demo的输出结果中，Parent的load方法先于Child调用，而它的装载顺序其实在Child之后。虽然在这种简单情况下我们可以辨别出各个类的load方法调用的顺序，但永远不要依赖这个顺序完成你的代码逻辑。一方面，这在后期的开发中极容易导致错误，另一方面，你实际上并不需要这么做。使用场景由于调用load方法时的环境很不安全，我们应该尽量减少load方法的逻辑。另一个原因是load方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在load方法中。一个常见的使用场景是在load方法中实现Method Swizzle： 1234567// In Other.m+ (void)load &#123; Method originalFunc = class_getInstanceMethod([self class], @selector(originalFunc)); Method swizzledFunc = class_getInstanceMethod([self class], @selector(swizzledFunc)); method_exchangeImplementations(originalFunc, swizzledFunc);&#125; 在Child类的load方法中，由于还没调用Other的load方法，所以输出结果是”Original Output”，而在main函数中，输出结果自然就变成了”Swizzled Output”。一般来说，除了Method Swizzle，别的逻辑都不应该放在load方法中实现。initialize这个方法在第一次给某个类发送消息时调用（比如实例化一个对象），并且只会调用一次。initialize方法实际上是一种惰性调用，也就是说如果一个类一直没被用到，那它的initialize方法也不会被调用，这一点有利于节约资源。调用规则与load方法类似的是，在initialize方法内部也会调用父类的方法，而且不需要我们显示的写出来。与load方法不同之处在于，即使子类没有实现initialize方法，也会调用父类的方法，这会导致一个很严重的问题：// In Parent.m+ (void)initialize { NSLog(@”Initialize Parent, caller Class %@”, [self class]);}// In Child.m// 注释掉initialize方法// In main.mChild *child = [Child new];运行后发现父类的initialize方法竟然调用了两次：2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Parent2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Child这是因为在创建子类对象时，首先要创建父类对象，所以会调用一次父类的initialize方法，然后创建子类时，尽管自己没有实现initialize方法，但还是会调用到父类的方法。虽然initialize方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用initialize方法的姿势如下：// In Parent.m+ (void)initialize { if (self == [Parent class]) { NSLog(@”Initialize Parent, caller Class %@”, [self class]); }}加上判断后，就不会因为子类而调用到自己的initialize方法了。使用场景initialize方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如NSMutableArray这种类型的实例化依赖于runtime的消息发送，所以显然无法在编译器初始化： 12345678910// In Parent.mstatic int someNumber = 0; // int类型可以在编译期赋值static NSMutableArray *someObjects;+ (void)initialize &#123; if (self == [Parent class]) &#123; // 不方便编译期复制的对象在这里赋值 someObjects = [[NSMutableArray alloc] init]; &#125;&#125; 总结1 load和initialize方法都会在实例化对象之前调用，以main函数为分水岭，前者在main函数之前调用，后者在main函数之后并且给对象发消息（实例化或者调用+方法）时候调用。这两个方法会被自动调用，不能手动调用它们。。 load和initialize方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类。 load方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量。 load和initialize方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。 总结2+load 首先，load方法是一定会在runtime中被调用的，只要类被添加到runtime中了，就会调用load方法，所以我们可以自己实现laod方法来在这个时候执行一些行为。 而且有意思的一点是，load方法不会覆盖。也就是说，如果子类实现了load方法，那么会先调用父类的load方法，然后又去执行子类的load方法。同样的，如果分类实现了load方法，也会先执行主类的load方法，然后又会去执行分类的load方法。所以父类的load会执行很多次，这一点需要注意。而且执行顺序是 类 -&gt; 子类 -&gt;分类。而不同类之间的顺序不一定。 +initialize 与load不同的是，initialize方法不一定会执行。只有当一个类第一次被发送消息的时候会执行，注意是第一次。什么叫发送消息呢，就是执行类的一些方法的时候。也就是说这个方法是懒加载，没有用到这个类就不会调用，可以节省系统资源。 还有一点截然相反，却更符合我们预期的就是，initialize方法会覆盖。也就是说如果子类实现了initialize方法，就不会执行父类的了，直接执行子类本身的。如果分类实现了initialize方法，也不会再执行主类的。所以initialize方法的执行覆盖顺序是 分类 -&gt; 子类 -&gt;类。且只会有一个initialize方法被执行。 原文1,原文2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swift报错UICollectionView must be initialized with a non-nil layout parameter]]></title>
      <url>%2F2017-05-05-swift%E6%8A%A5%E9%94%99UICollectionView%20must%20be%20initialized%20with%20a%20non-nil%20layout%20parameter.html</url>
      <content type="text"><![CDATA[今天学习swift的UICollectionView时候项目运行就报错，控制台显示“UICollectionView must be initialized with a non-nil layout parameter”，意思很明显就是UICollectionView初始化时候没有给个有效的layout，就是说UICollectionViewFlowLayout没有初始化，我就纳闷了明明是初始化了啊 123全局变量 private var layout = UICollectionViewFlowLayout() private var collectionView :UICollectionView() 然后在viewDidLoad里 1collectionView = UICollectionView(frame: self.view.bounds, collectionViewLayout: layout) 看起来没什么问题，才初学swift不知道 1private var collectionView :UICollectionView() 这样写已经是初始化了，所以就报错了，应该在声明变量的时候改为如下写法 1private var collectionView :UICollectionView! 这样就就只是声明变量了再在viewDidLoad里初始化使用就没问题了 12 layout = UICollectionViewFlowLayout()collectionView = UICollectionView(frame: self.view.bounds, collectionViewLayout: layout)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios9设置通用链接]]></title>
      <url>%2F2017-04-26-ios9%E8%AE%BE%E7%BD%AE%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5.html</url>
      <content type="text"><![CDATA[什么是通用链接？通过唯一的网址, 就可以链接一个特定的视图到你的 APP 里面, 不需要特别的 schema通用链接是一种能够方便的通过传统 HTTP 链接来启动 APP, 使 用相同的网址打开网站和 APP。当你的应用支持通用链接，iOS9 之后 , 用户可以点击一个链接跳转到你的网站,并获得无缝重定向到您安装的应用程序,而无需通过 Safari 浏览器。如果你的应用不支持的话,点击链接将会用 Safari 来打开。。试想一下 Twitter 使用了通用链接, 那么你每在 twitter.com 点击一个链接, 你的 iOS 设备都会在 Twitter 里面自动打开这个页面, 而不是当你没有安装时转到普通的网页。这个用户体验是顺畅的, 最重要的是用户不会失去上下文（跳到 APP 后 Safari 上不再留下空标签）。 通用链接的优点通用链接比自定义的URL链接有几处尤为突出的好处,具体来说,通用链接独特性：与自定义的URL链接相比,通用链接不能被其他的应用程序所访问,因为 1:它们使用的是标准的HTTP 或 HTTPS 链接到你的网站。安全性：当用户安装应用程序,iOS会检查您已经上传到web服务器文件,以确 2:保您的网站允许你的应用程序能打开代表它的URL 文件,只要你创建并且上传该文件,那么你的应用和服务器之间的关联是安全的。灵活性：当你的应用程序没有被安装的时候,通用链接照样能够工作。 3:当用户没有安装你的应用程序,点击该链接,将会以用户所期望的以Safari的形式访问。简单性：通用链接既能支持你的网站,又能支持你的应用私有性：其他的应用程序能和你的应用程序通信,不管你的应用是否被安装。 准备使用通用链接实现通用链接不难, 但首先必须遵守一些先决条件。如下： 有一个注册的域名 通过 SSL 访问域名 支持上传一个 JSON 文件到你的域名 至少 iOS 9 beta 2 版本 [下载]，这很重要,因为如果是之前的测试版本你需要做额外的操作。 至少 Xcode 7 beta 2如果你都有了, 那就来按照下面3个步骤来做吧。 1.开启 Associated Domains 域: 进入苹果Apple Developer — Member Center - Certificates, Identifiers &amp; Profiles – Identifiers - App IDs –Edit 然后开启打钩 Associated Domains 后保存。 2.添加域名到 Capabilities首先, 你必须在 Xcode 的 capabilities 里 添加你的 APP 域名, 必须用 applinks: 前置它：还添加一些你可能拥有的子域和扩展（www.domain.com, news.domain.com 等等）。 用applinks: 前缀添加所有域名, 同时不要忘了包含所有可能需要的子域名 这将使你的 APP 从你的域名请求一个特殊的 JSON 文件 apple-app-site-association。当你第一次启动 APP，它会从 https://domain.com/apple-app-site-association 下载这个文件。跳到下个步骤来了解如何构建这个文件。 3.上传 apple-app-site-association 文件该文件必须存在且为了安全原因可使用 SSL 通过 GET 请求访问到。你可以打开一个文本编辑器然后写一个这样的简单 JSON 格式： 123456789101112131415&#123; &quot;applinks&quot;: &#123; &quot;apps&quot;: [], &quot;details&quot;: [ &#123; &quot;appID&quot;: &quot;L2LYHXGC7E.com.domain.Appr&quot;, &quot;paths&quot;: [ &quot;*&quot; ,&quot;/&quot;,&quot;/archives/&quot;,&quot;/archives/*&quot;] &#125;, &#123; &quot;appID&quot;: &quot;ABCD1234.com.apple.wwdc&quot;, &quot;paths&quot;: [ &quot;*&quot; ] &#125; ] &#125;&#125; 最后, 上传这个文件到你的域名根目录。如果你打开 https://domain.com/apple-app-site-association 可以看到你的文件, 我看到网上一部分人说可以打开苹果的这个网址检测apple-app-site-association是否是有效，在我部署完以上步骤后测试下最后一项Link to Application也是无效的但在我做完所有步骤后发现已经实现了本文要实现的功能，也就是说具体效果还是要以自己测试为准。那么你就可以继续下一步了。 注意事项（1） 1, paths 路径是大小写敏感的 2, paths 内容可明确哪些通用链接需要被处理,哪些不需要 3, NOT 使用:为了明确指出不被处理的链接,可增加 “NOT”在链接前面例 如 “paths”: [ “/wwdc/news/“, “NOT /videos/wwdc/2010/“, “/videos/wwdc/201?/“] 4, 你可以使用 * 明确所有的网页 5, 也可以使用一个明确的的 URL,例如 /wwdc/news/ 6, 也可以追加 到你的 URL ,例如 /videos/wwdc/2015/ 也可以使用 来匹配任何字符,使用 ? 来匹配一个字符,可以在路径 中使用这种混搭的形式, 例如 /foo//bar/201?/mypage 注意事项（2） 1, “appID”组成部分:TeamID + BundleId TeamID 2, BundleId 一定要和 APP 的 BundleId 一致。 3, apple-app-site-association 文件不能带后缀 4, apple-app-site-association 文件需要上传到网站根目录 5, 每一个代表着应用的 字典,必须包含一个 appID 和 paths, appID 是teamID 和 bundleID,paths 是一个字符串的数组明确着你的应用支持的通用链接和你的应用程序不支持的通用连接内容。 下图就是 “appID”组成部分:TeamID + BundleId TeamID 最后为了在 APP 里支持通用链接, 你需要在 AppDelegate 里实现相对应的逻辑 附上我那个验证apple-app-site-association的截图吧B6B1BAB7-FBDD-4CFD-8862-9B78738787E4 posted by (C)sky521 效果图 在“全聚星”打开 IMG_0413 posted by (C)sky521]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决xcode8.2控制台数据打印不全]]></title>
      <url>%2F2017-04-25-%E8%A7%A3%E5%86%B3xcode8-2-NSlog%E6%95%B0%E6%8D%AE%E6%89%93%E5%8D%B0%E4%B8%8D%E5%85%A8.html</url>
      <content type="text"><![CDATA[最近升级Xcode8，开发工具出现了，控制台log数据不完整，经常打印一半，就没有了，经过查询一番终于找到了解决办法! 解决办法：宏定义去log日志数据，把NSlog换成print 123456789#ifdef DEBUG#define DLog( s, ... ) printf(&quot;class: &lt;%p %s:(%d) &gt; method: %s \n%s\n&quot;, self, [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String], __LINE__, __PRETTY_FUNCTION__, [[NSString stringWithFormat:(s), ##__VA_ARGS__] UTF8String] )#else#define DLog( s, ... )#endif 日了狗了 让我纠结半天 ，心想xcode不会出现这么低级的问题吧，没想查了一下还真有这个问题，事实证明‘实践是证明真理的唯一标准’啊。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决TableViewCell和CollectionViewCell复用布局错乱问题]]></title>
      <url>%2F2017-03-30-%E8%A7%A3%E5%86%B3TableViewCell%E5%92%8CCollectionViewCell%E5%A4%8D%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[解决TableViewCell和UICollectionViewCell使用过程中因为重用机制问题造成数据重复显示或者布局错乱问题。 常规配置如下 当超过tableView显示的范围的时候 后面显示的内容将会和前面重复 123456789101112131415161718192021// 这样配置的话超过页面显示的内容会重复出现- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义唯一标识 static NSString *CellIdentifier = @&quot;Cell&quot;; // 通过唯一标识创建cell实例 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125;//通过以下3方案可以解决 方案一： 让每个cell都拥有一个对应的标识 这样做也会让cell无法重用 所以也就不会是重复显示了 显示内容比较多时内存占用也是比较多的 123456789101112131415161718/ /方案一 通过不让他重用cell 来解决重复显示 不同的是每个cell对应一个标识- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义cell标识 每个cell对应一个自己的标识 NSString *CellIdentifier = [NSString stringWithFormat:@&quot;cell%ld%ld&quot;,indexPath.section,indexPath.row]; // 通过不同标识创建cell实例 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125; 方案二： 同样取消cell的重用机制，通过indexPath来创建cell 将可以解决重复显示问题 不过这样做相对于大数据来说内存就比较吃紧了 123456789101112131415161718// 方案二 通过不让他重用cell 来解决重复显示- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义唯一标识 static NSString *CellIdentifier = @&quot;Cell&quot;; // 通过indexPath创建cell实例 每一个cell都是单独的 UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125; ###方案三 只要最后一个显示的cell内容不为空，然后把它的子视图全部删除，等同于把这个cell单独出来了 然后跟新数据就可以解决重复显示 12345678910111213141516171819202122232425// 方案三 当页面拉动需要显示新数据的时候，把最后一个cell进行删除 就有可以自定义cell 此方案即可避免重复显示，又重用了cell相对内存管理来说是最好的方案 前两者相对比较消耗内存- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义唯一标识 static NSString *CellIdentifier = @&quot;Cell&quot;; // 通过唯一标识创建cell实例 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; else//当页面拉动的时候 当cell存在并且最后一个存在 把它进行删除就出来一个独特的cell我们在进行数据配置即可避免 &#123; while ([cell.contentView.subviews lastObject] != nil) &#123; [(UIView *)[cell.contentView.subviews lastObject] removeFromSuperview]; &#125; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125; 经过测试UIcollectionViewCell布局错乱用第一种方法同样可以解决问题，实际解决情况还要自己测试才可以。 最后贴一个我的UIcollectionViewCell解决复用的代码 123456789101112- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; NSString *CellIdentifier = [NSString stringWithFormat:@&quot;cell%ld%ld&quot;,indexPath.section,indexPath.row]; [self.collectionView registerNib:[UINib nibWithNibName:@&quot;AudienceViewCollectionViewCell&quot; bundle:nil] forCellWithReuseIdentifier:CellIdentifier]; // 通过不同标识创建cell实例 AudienceViewCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:CellIdentifier forIndexPath:indexPath]; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift函数与闭包的应用实例]]></title>
      <url>%2F2017-03-29-Swift%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B.html</url>
      <content type="text"><![CDATA[今天的博客算是比较基础的，还是那句话，基础这东西在什么时候都是最重要的。说到函数，只要是写过程序就肯定知道函数是怎么回事，今天就来讨论一下Swift中的函数的特性以及Swift中的闭包。今天的一些小实例中回类比一下Objective-C中的函数的写法等等。Swift中的函数还是有许多好用的特性的，比如输入参数，使用元组返回多个值， 定义形参名，设定默认参数以及可变参数等等一些好用的特性。而在Swift中的闭包就是Objective-C中的Block, 除了语法不通外，两者的用法是一样的。废话少说，开始今天的主题，先搞一搞Swift中的函数，然后在搞一搞Swift中的闭包。 一.Swift中的函数 1. 函数的定义与使用 在介绍Swift中的函数之前，我想用Objective-C中的一个简单的加法函数来作为引子，然后类比着实现一下Swift中相同功能的函数。关于函数定义就比较简单了，就是一些语法的东西，下面的代码片段是Objc中求两个整数之和的函数，并返回两个数的和。- (NSInteger)sumNumber1:(NSInteger) number1 number2:(NSInteger) number2 { return number1 + number2;} 函数的功能比较简单了，就是把两个整数传进来，然后返回两个整数的和。接下来将用Swift语言实现，也好通过这个实例来熟悉一下Swift语言中定义函数的语法。下方是Swift语言中求两个整数之和的函数。语法比较简单了，在Swift中定义函数，我们会使用到关键字func来声明函数。1 //函数定义2 func sum (number1:Int, number2:Int) -&gt; Int{3 return number1 + number2;4 } 用文字来描述Swift定义基本函数的语法就是: func 函数名 （形参列表） -&gt; 返回值类型 { 函数体}，这样你就可以定义一个函数了。当然，函数定义时还有好多其他的用法，下面会详细介绍。上面函数的调用方法如下：1 let sumTwoNubmer = sum(2, number2: 3);&nbsp; 2. 函数中的形参列表 关于函数中的形参列表还是有必要提上一嘴的，因为形参列表作为函数数据源之一，所以把参数列表好好的搞一搞还是很有必要的。参数列表也有很多好用的使用方式，接下来详细的介绍一下函数的形参列表。 (1) 默认的形参是常量（let） 在函数的形参列表中，默认的形参是常量。也就是相当于用let关键字对形参进行修饰了。我们可以做个试验，把上面加法函数做一个修改，在加法函数中对number1进行加1操作，你会得到一个错误，这个错误的大体意思就是&ldquo;number1是不可被修改的，因为它是let类型的常量&rdquo;。并且编译器还给人出了Fix-it（修复）的方案，就是在number1前面使用var关键字进行修饰，使其成为变量，这样才可以修改其值。 上面说这么多，一句话：形参默认是常量，如果你想让其是变量，那么你可以使用var关键字进行修饰，这样被关键字var修饰的变量在函数中就可以被修改。下方就是报的这个错误，和编译器提供的解决方案。（在Objc中默认可以在函数中改变形参的值）&nbsp; （2）给形参命名 为了代码的可读性和可维护性，我们在定义函数时，需要为每个参数名一个名字，这样调用者见名知意，很容易就知道这个参数代表什么意思了。接下来还是在上述加法函数中进行修改，为每个参数名一个名字，并看一下调用方式。修改上面的函数，给第一个形参命名成numberOne, 第二个形参为numberTwo, 下方是修改后的函数。 紧接着sum()函数的调用方式也会有所改变，在调用函数时编译器会给出参数的名称，这样调用者一目了然。1 //函数定义2 func sum (numberOne number1:Int, numberTwo number2:Int) -&gt; Int{3 return number1 + number2;4 }56 let sumTwoNubmer = sum(numberOne: 10, numberTwo: 20); &nbsp;调用上述函数时，下方是编译器给出的提示，一目了然呢。 关于Swift中参数名的内容，要说明的是在Swift1.0的时候，你可以在参数前面添加上#号，然后参数名就与变量（或者常量）的名字相同，而Swift2.0后这个东西去掉了，因为默认就相当于Swift1.0中添加#号。&nbsp; (3) 函数的传参与传引用 先暂且这么说着，在C语言的函数中可以给函数传入参数，或者传入实参的内存地址就是所谓的传引用。如果传入的是引用的话，在函数中对值进行修改的话，那么出了函数，这个被修改的值是可以被保留的。在Swift中也是可以的，不过你需要使用inout关键字修饰形参，并且在使用该函数时，用&amp;来修饰。这一点和C语言中类似，&amp;就是取地址符。下方是inout使用的一个小实例。1 func incrementStepTwo (inout myNumber:Int) {2 myNumber += 23 }4 var myTestNumber = 65 incrementStepTow(&amp;myTestNumber) //myTestNumber = 8 myTestNumber变量经过incrementStepTwo()函数后，其值就会增加2。当然前提是myTestNumber是变量，如果myTestNumber是常量的话，那么对不起，调用该函数就会报错，下面是把var改成let后IDE给的错误提示。错误原因很显然是你动了一个不该动的值，也就是常量不可再次被修改的。&nbsp; (4) 不定参数函数 不定参数函数也就是形参的个数是不定的，但是形参的类型必须是相同的。不定形参在使用时怎么取呢？不定个数的形参实际上是一个数组，我们可以通过for循环的形式来遍历出每个形参的值，然后使用就可以了。下方incrementMultableAdd()函数的形参的个数是不定的，其功能是求多个整数的和。在函数中我们只需遍历每个参数，然后把每个参数进行相加，最后返回所求的和即可。函数比较简单，再此就不在啰嗦了。&nbsp; (5) 默认形参值 在Swift语言中是支持给形参赋初始值的，这一点在其他一些编程语言中也是支持的。但是Objective-C这么看似古老的语言中就不支持给形参指定初始值，在Swift这门现代编程语言中是支持这一特性的。默认参数要从参数列表后开始为参数指定默认值，不然就会报错。下方就是为函数的形参指定默认参数的示例。一个表白的方法sayLove(), 形参youName默认是&ldquo;山伯&rdquo;， 形参loverName默认是&ldquo;英台&rdquo;。 紧接着是sayLove函数的三种不同的调用方式，在调用函数时你可以不传参数，可以传一个参数，当然传两个也是没问题的。&nbsp; 因为函数的每个参数都是有名字的，在含有默认参数的函数调用时，可以给任意一个参数进行传值，其他参数取默认值，这也是Swift的一大特色之一，具体请看如下简单的代码示例：&nbsp; 3.函数类型 每个函数都有自己的所属类型，函数类型说白了就是如果两个函数参数列表相同以及返回值类型相同，那么这两个函数就有着相同的函数类型。在Swift中可以定义一个变量或者常量来存储一个函数的类型。接下来将用过一个实例还介绍一下函数类型是个什么东西。 &nbsp; (1) 首先创建两个函数类型相同的函数，一个函数返回两个整数的差值，另一个函数返回两个整数的乘积。当然这两个函数比较简单，直接上代码：1 //现定义两个函数类型相同的函数2 func diff (number1:Int, number2:Int) -&gt; Int {3 return number1 - number2;4 }56 func mul (number1:Int, number2:Int) -&gt; Int {7 return number1 number2;8 } (2) 函数定义好后，接着要定义个一个枚举来枚举每种函数的类型，下面定义这个枚举在选择函数时会用到，枚举定义如下：1 //定义两种计算的枚举类型2 enum CountType:Int {3 case DiffCount = 04 case MulCount5 } (3) 接下来就是把(1)和(2)中定义的东西通过一个函数来组合起来。说白了，就是定义个函数来通过枚举值返回这个枚举值所对应的函数类型。有时候说多了容易犯迷糊，就直接上代码得了。下方函数的功能就是根据传进来的枚举值来返回相应的函数类型。 1 //选择类型的函数，并返回相应的函数类型 2 func choiseCountType(countType:CountType) -&gt; ((Int, Int) -&gt; Int) { 3 //函数类型变量 4 var myFuncType:(Int, Int) -&gt; Int 5 6 switch countType { 7 case .DiffCount: 8 myFuncType = diff 9 case .MulCount:10 myFuncType = mul11 }12 return myFuncType;13 } (4) 接下来就是使用(3)中定义的函数了，首先我们需要定义一个相应函数类型((Int, Int) -&gt; Int)的变量来接收choiseCountType()函数中返回的函数类型，然后调用该函数类型变量，在Playground中执行的结果如下：&nbsp; &nbsp; &nbsp;4.函数嵌套 我们可以把 3 中的代码使用函数嵌套进行重写，在Swift中是支持函数嵌套的。 所以可以吧3.1和3.2中的函数放到3.3函数中的，所以我们可以对上述代码使用函数嵌套进行重写。使用函数嵌套重写后的代码如下所示，当然，choiseCountType()函数的调用方式没用发生改变，重写后的调用方式和3.4中的调用方式是一样一样的。 1 //选择类型的函数，并返回相应的函数类型 2 func choiseCountType(countType:CountType) -&gt; ((Int, Int) -&gt; Int) { 3 4 //现定义两个函数类型相同的函数 5 func diff (number1:Int, number2:Int) -&gt; Int { 6 return number1 - number2; 7 } 8 9 func mul (number1:Int, number2:Int) -&gt; Int {10 return number1 number2;11 }121314 //函数类型变量15 var myFuncType:(Int, Int) -&gt; Int1617 switch countType {18 case .DiffCount:19 myFuncType = diff20 case .MulCount:21 myFuncType = mul22 }23 return myFuncType;24 }&nbsp; 二. 闭包 说道Swift中的闭包呢，不得不提的就是Objective-C中的Block, 其实两者是一个东西，使用方式以及使用场景都是相同的。我们完全可以类比着Objective-C中的Block来介绍一下Swift中的Closure（闭包）。其实就是匿名函数。接下来的这段内容，先介绍一下Swift中Closure的基本语法，然后在类比着ObjC中的Block窥探一下Closure的使用场景。 1.Closure变量的声明 Closure就是匿名函数，我们可以定义一个闭包变量，而这个闭包变量的类型就是我们上面介绍的&ldquo;函数类型&rdquo;。定义一个闭包变量其实就是定义一个特定函数类型的变量，方式如下。因为Closure变量没有赋初始值，所以我们把其声明为可选类型的变量。在使用时，用!强制打开即可。1 var myCloure0:((Int, Int) -&gt; Int)? 除了上面的方式外，我们还用另一种常用的声明闭包变量的方式。那就是使用关键字typealias定义一个特定函数类型，我们就可以拿着这个类型去声明一个Closure变量了，如下所示1 //定义闭包类型 (就是一个函数类型)2 typealias MyClosureType = (Int, Int) -&gt; Int3 var myCloure:MyClosureType?&nbsp; 2. 给Closure变量赋值 给Closure变量赋值，其实就是把一个函数体赋值给一个函数类型的变量，和函数的定义区别不大。但是给闭包变量赋值的函数体中含有参数列表，并且参数列表和真正的函数体之间使用关键字in来分割。 闭包可选变量的调用方式与普通函数没什么两样，唯一不同的是这个函数需要用!来强制打开才可以使用。赋值和调用方式如下。&nbsp; 3. 闭包回调的应用实例 暂且先称作闭包回调吧，其实就是Objc中的Block回调。在Swift中的闭包回调和Objc中的Block回调用法一致，下方将会通过一个实例来介绍一下闭包的应用之一。下方会创建两个视图控制器，我们暂且称为FirstViewController和SecondViewController。在FirstViewController上有一个Label和一个Button, 这个Button用来跳转到SecondViewController, 而这个Label用来显示从SecondViewController中回调过来的值。 而SecondViewController也有一个TextField和一个Button, 点击Button就会把输入框中的值通过闭包回调回传到FirstViewController然后在FirstViewController上的Label显示。 (1) 构建这个实例的第一步要做的就是使用Stroyboard把我们所需的控件布局好，并且管理相应的类。当然我们这个Demo的重点不在于如何去布局控件，如何去关联控件，以及如何去使用控件，所以上述的这些就不做赘述了。这个实例的重点在于如何使用Closure实现值的回调。下方是我们的控件布局和目录结构的截图，从Storyboard上的控件来看，功能也就一目了然了。点击&ldquo;FirstViewController&rdquo; 上的&ldquo;Go SecondViewController&rdquo;按钮，就会跳转到 &ldquo;SecondViewController&rdquo; 。 在SecondViewController视图上的输入框输入数值，点击Back按钮返回到FirstViewController, 同时把输入框中的文本通过闭包回调的形式回传过来在FristViewController的label上显示。大致就这个简单的功能。&nbsp; （2）FirstViewController.swift中的内容 FirstViewController.swift中的内容比较简单，就关联一个Label控件和一个按钮点击的事件，点击按钮就会跳转到SecondViewController，具体代码如下，在此就不啰嗦了，请看代码中的注释。下方代码重要的一点是在跳转到SecondViewController时要实现其提供的闭包回调，以便接受回传过来的值。 1 // 2 // FirstViewController.swift 3 // SwiftDemo 4 // 5 // Created by Mr.LuDashi on 15/11/18. 6 // Copyright &copy; 2015年 ZeluLi. All rights reserved. 7 // 8 9 import UIKit1011 class FirstViewController: UIViewController {1213 @IBOutlet var showTextLabel: UILabel! //展示回调过来的文字信息1415 override func viewDidLoad() {16 super.viewDidLoad()17 }1819 override func didReceiveMemoryWarning() {20 super.didReceiveMemoryWarning()21 }2223 //点击按钮跳转到SecondViewController24 @IBAction func tapGoSecondViewControllerButton(sender: UIButton) {25 //从Storyboard上加载SecondViewController26 let secondVC = UIStoryboard(name: “Main”, bundle: NSBundle.mainBundle()).instantiateViewControllerWithIdentifier(“SecondViewController”)as! SecondViewController2728 //实现回调，接收回调过来的值29 secondVC.setBackMyClosure { (inputText:String) -&gt; Void in30 self.showTextLabel.text = inputText31 }3233 //push到SecondViewController34 self.navigationController?.pushViewController(secondVC, animated: true)35 }36 }&nbsp; (3) SecondViewController.swift中的内容 SecondViewController.swift中的内容也不麻烦，就是除了关联控件和事件外，还定义了一个闭包类型（函数类型），然后使用这个特定的函数类型声明了一个此函数类型对应的变量。我们可以通过这个变量来接受上个页面传过来的闭包体，从而把用户输入的值，通过这个闭包体回传到上个页面。具体代码实现如下： 1 // 2 // SecondViewController.swift 3 // SwiftDemo 4 // 5 // Created by Mr.LuDashi on 15/11/18. 6 // Copyright &copy; 2015年 ZeluLi. All rights reserved. 7 // 8 9 import UIKit1011 typealias InputClosureType = (String) -&gt; Void //定义闭包类型（特定的函数类型函数类型）1213 class SecondViewController: UIViewController {1415 @IBOutlet var inputTextField: UITextField! //输入框，让用户输入值，然后通过闭包回调到上一个页面1617 var backClosure:InputClosureType? //接收上个页面穿过来的闭包块1819 override func viewDidLoad() {20 super.viewDidLoad()21 }2223 override func didReceiveMemoryWarning() {24 super.didReceiveMemoryWarning()25 }2627 //闭包变量的Seter方法28 func setBackMyClosure(tempClosure:InputClosureType) {29 self.backClosure = tempClosure30 }3132 @IBAction func tapBackButton(sender: UIButton) {33 if self.backClosure != nil {34 let tempString:String? = self.inputTextField.text35 if tempString != nil {36 self.backClosure!(tempString!)37 }38 }39 self.navigationController!.popViewControllerAnimated(true)40 }41 }&nbsp; (4) 经过上面的步骤这个实例已经完成，接下来就是看一下运行效果的时间了。本来想做成Git动态图的，感觉实例功能简单，而且UI上也比较简单，就没做，还是看截图吧。运行效果的截图如下： 4.数组中常用的闭包函数 在Swift的数组中自带了一些比较好用的闭包函数，例如Map, Filter, Reduce。接下来就好好的看一下这些闭包，用起来还是比较爽的。 (1) Map(映射) 说到Map的用法和功能，不能不说的是如果你使用过ReactiveCocoa框架，那么对里边的Sequence中的Map的使用方式并不陌生。其实两者的使用方法和功能是极为相似的。如果你没使用过RAC中的Map，那也无关紧要，接下来我们先上段代码开看一下数组中的Map闭包函数。 通过上面的代码段以及运行结果，我们不难看出，map闭包函数的功能就是对数组中的每一项进行遍历，然后通过映射规则对数组中的每一项进行处理，最终的返回结果是处理后的数组（以一个新的数组形式出现）。当然，原来数组中的元素值是保持不变的，这就是map闭包函数的用法与功能。&nbsp;&nbsp; (2) Filter (过滤器) Filter的用法还是比较好理解的，Filter就是一个漏勺，就是用来过滤符合条件的数据的。在ReactiveCocoa中的Sequence也是有Filter的，用法还是来过滤Sequence中的数据的。而在数组中的Filter用来过滤数组中的数据，并且返回新的数组，新的数组中存放的就是符合条件的数据。Filter的用法如下实例，下方的实例就是一个身高的过滤，过滤掉身高小于173的人，返回大于等于173的身高数据。 （3）Reduce&nbsp; 在ReactiveCocoa中也是有Reduce这个概念的，ReactiveCocoa中使用Reduce来合并消减信号量。在swift的数组中使用Reduce闭包函数来合并items, 并且合并后的Value。下方的实例是一个Salary的数组，其中存放的是每个月的薪水。我们要使用Reduce闭包函数来计算总的薪水。下方是DEMO的截图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift字符串常用操作]]></title>
      <url>%2F2017-03-28-Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html</url>
      <content type="text"><![CDATA[swift 中关于取子串有4 个方法 str.index(after: String.Index) str.index(before: String.Index) str.index(String.Index, offsetBy: String.IndexDistance) str.index(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index) 分别是什么, 该如何使用?下面来看看本例中, 我们创建一个字符串"Hello, playground" , 如下 var str = "Hello, playground" 字符索引 startIndex 和 endIndex startIndex 是第一个字符的索引, 也就是 endIndex 是最后一个字符索引 +1 // character str[str.startIndex] // H str[str.endIndex] // error: after last character // range let range = str.startIndex ..&lt; str.endIndex str[range] // "Hello, playground" after index(after: String.Index)after 指向给定索引后面的一个索引(类似与 + 1) // character let index = str.index(after: str.startIndex) str[index] // "e" // range let range = str.index(after: str.startIndex)..&lt;str.endIndex str[range] // "ello, playground" before index(before: String.Index)before 指向给定索引之前的一个索引(类似与 - 1) // character let index = str.index(before: str.endIndex) str[index] // d // range let range = str.startIndex ..&lt; str.index(before: str.endIndex) str[range] // Hello, playgroun offsetBy index(String.Index, offsetBy: String.IndexDistance)offsetBy 的值可以为正或是负, 正则表示向后, 负则相反.别被offsetBy 的 String.IndexDistance 类型吓到, 本身其实是一个 Int.(类似于+n 和 -n) // characterlet index = str.index(str.startIndex, offsetBy: 7)str[index] // p // rangelet start = str.index(str.startIndex, offsetBy: 7)let end = str.index(str.endIndex, offsetBy: -6)let range = start ..&lt; endstr[range] // play limitedBy index(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index) limitedBy 在 offset 过大导致溢出错误的时候很有用.这个返回值是一个可选值, 如果 offsetBy 超过了 limitBy, 则返回 nil. // characterif let index = str.index(str.startIndex, offsetBy: 7, limitedBy: str.endIndex) {str[index] // p} 上面这段代码中如果offset 设置为 77, 返回值就是 nil, if 中的代码就会跳过 所以如果你要取子串的正确姿势是什么? 取某个位置之后的所有字符str.substring(from: str.index(str.startIndex, offsetBy: 7)) // playground取倒数某个位置之后的所有字符str.substring(from: str.index(str.endIndex, offsetBy: -10)) //playground取某个位置之前的所有字符str.substring(to: str.index(str.startIndex, offsetBy: 5)) //Hello取倒数某个位置之前的所有字符str.substring(to: str.index(str.endIndex, offsetBy: -12)) //Hello取中间的某个字符串str.substring(with: str.index(str.startIndex, offsetBy: 7) ..&lt; str.index(str.endIndex, offsetBy: -6)) // play]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[myResume]]></title>
      <url>%2F2017-03-16-myResume.html</url>
      <content type="text"><![CDATA[简历预览王森男|未婚|1992年2月生| 户口：河南-南阳| 现居住于:北京-朝阳区2.5年工作经验 |团员Tel:15617877692 E-mail：sslxws@163.com求职意向工作性质：全职期望职业：iOS开发工程师期望行业：互联网技术开发工作地区：北京期望月薪：面议目前状况：我目前在职，正考虑换个新环境（如有合适的工作机会，到岗时间2个星期左右）专业技能1.熟练掌握Object-C、Swift语言开发，熟悉C语言、html、css，以及JavaScprit的简单使用2.熟悉 runtime 以及 runloop3. 熟悉并掌握多线程技术，如 NSThread、GCD、NSOpeartion；4.熟悉MRC ARC 内存管理机制5.熟练使用Core Animation、UIView开发动画6.熟练使用WebStorm并掌握H5与iOS交互7.熟练掌握百度地图、高德地图的定位、导航、自定义标注、地理编码等功能。 8.熟练使用支付宝支付、微信支付、银联支付等多种支付方式。9.熟练使用推送通知，自定义消息的处理。10.掌握Instruments leaks内存检测以及单元测试提升程序的稳定性。11.熟练使用各种设计模式，如MVC 模式（MVVM模式）、代理模式、单例模式、观察者模式等设计模式 12.熟练使用AFNetworking、SDWebImage,Masonry第三方框架13. 熟悉 SourceTree、Github 代码管理工具,jenkins可持续开发自我评价对于iOS的技术水平可以单独做完整个项目,负责各个模块的开发调试。有较强的学习能力和探索精神。工作经历2016/06 – 至今 北京易聚创意科技有限公司|iOS开发工程师 行业类别： 互联网/电子商务|规模：100-499人|职位月薪：15000-25000元/月工作描述：带领团队共同开发‘全聚星’直播App，搭建gitlab代码管理工具配置环境，搭建禅道项目管理Bug反馈处理工具，搭建Jenkins持续集成配置环境，设计项目框架；实现直播模块，商城模块，私信聊天；辅助其他开发成员解决疑难问题，修复Bug,根据开发日期分配任务2015/09 – 2016/05北京青籁科技有限公司|iOS工程师 行业类别： 互联网/电子商务|规模：100-499人|职位月薪：10001-15000元/月工作描述： 独立开发“理大师”app的用户端，负责整个项目的框架、逻辑处理以及各个模块的开发，地图定位 poi 搜索 导航，微信支付和支付宝支付，推送通知，配合后台和web前端交互处理h5界面，维护升级。 实现一个可以在线预约下单上门推拿的健康医疗服务。（包含用户端与医生端）2014/10 – 2015/09北京溥联信息科技有限公司|iOS开发实习生 行业类别： 互联网/电子商务|企业性质：事业单位|规模：20-99人|职位月薪：6001-8000元/月工作描述：快停App手机端的开发，根据需求进行iOS平台客户端软件的开发和维护,设计项目框架，实现界面展示与后台调试api完善项目功能，维护升级。 实现了一个可以快速停车为车主提供便捷精准可靠的停车服务（精准定位，预约停车，停车导航，智能计时，在线支付） 业绩描述：负责项目所有板块的开发， 独自解决快停App首页加载地图自定义上千个标注点的卡顿现象，实现区域标注点与全局标注点的切换，提高程序的流畅度，提升用户体验。离职原因：项目经验2016/06 – 至今 全聚星直播责任描述：带领iOS开发组共同开发‘全聚星’直播App，搭建gitlab代码管理工具配置环境，搭建禅道项目管理Bug反馈处理工具，搭建Jenkins持续集成配置环境，设计项目框架；实现直播模块，商城模块，私信聊天；辅助其他开发成员解决疑难问题，修复Bug,根据开发日期分配任务。项目简介：全聚星是由香港上市企业-中国创意集团斥巨资打造的国内首家艺人养成互动平台。我们以赵薇、佟大为等明星股东为支点、专业化的艺人培养机制为保障， 高品质的互动视频内容为跳板、为才艺新人提供全方位的培养、包装体系。全聚星积极探索符合国内业态发展需要的新型娱乐经济产业模式，汇聚互动综艺直播、明星直播、才艺直播等高品质互动视频内容，率先开启全民互动娱乐2.0浪潮。2015/09 – 2016/05理大师用户端和管理端责任描述：独立开发“理大师”app的用户端，负责整个项目的框架、逻辑处理以及各个模块的开发，地图定位 poi 搜索 导航，微信支付和支付宝支付，推送通知，配合后台和web前端交互处理h5界面，维护升级。项目简介：理大师以中医理疗推拿为核心的O2O健康理疗上门服务的平台。专注健康，贴心服务，以百年传承的中医养生医疗体系为核心，融合西医及美式整脊疗法先进的检测与健康管理方法，为用户提供定制化的名医大师健康理疗服务。2014/10 – 2015/09快停责任描述：快停App手机端的开发，根据需求进行iOS平台客户端软件的开发和维护,设计项目框架，实现界面展示与后台调试api完善项目功能，维护升级。项目简介：&nbsp;&nbsp;快停司机端:为车主提供便捷精准可靠的停车服务（精准定位，停车导航，智能计时，在线支付），为车主彻底解决城市出行中停车难的问题，同时为停车场提供智能引导，平台支付，高效管理，实现停车场效率与收益最优化.&nbsp;&nbsp;&nbsp;&nbsp; 教育经历2016/07 – 至今 郑州大学远程教育|计算机科学与技术|本科|非统招2013/09 – 2015/06河南广播电视大学|机械设计制造及其自动化|大专|统招语言能力英语 ：读写能力熟练| 听说能力良好]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo配合github搭建免费博客，绑定域名]]></title>
      <url>%2F2017-03-15-Hexo%E9%85%8D%E5%90%88github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D.html</url>
      <content type="text"><![CDATA[出发点：有那么大的博客平台不用为什么自己搭建博客，说白了就是玩玩坚持写几篇博客然后就是装逼了呗。本篇文章在我的简书地址今天要讲的搭建博客教程很简单不需要什么钱当然有钱可以买虚拟机配个数据库可以玩wordpress搭建博客更简单，记得万网有活动几块钱就可以买个一年的虚拟机活动长期有可以看看，这里就不详细介绍了。言归正传，本篇博客说的是用github和 Hexo搭建一个免费的博客网站，搭建完看起来像这样 http://ws1227.github.io 如果有个人域名就可以类似这样http://wangsen.website/ 后边再介绍。 先说下需要的基本条件：安装Node（必须） 作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。提供一个mac版本的https://pan.baidu.com/s/1gf5NSyf 不用翻墙下载了安装Git（必须）作用：把本地的hexo内容提交到github上去. 安装Xcode就自带有Git，我就不多说了。没有的话可以去https://git-scm.com/downloads 下载申请GitHub（必须）作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。安装HexoNode和Git都安装好后，可执行如下命令安装hexo：1$ sudo npm install -g hexo创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：1hexo init好啦，至此，全部安装工作已经完成！因为Hexo编写的文章都是用 markdown语法写的 所以需要生成静态界面也就是Html网页。 生成静态页面继续在刚才的Blog目录下执行如下命令，生成静态页面 1hexo generate （hexo g 缩写也可以） 本地启动启动本地服务，进行文章预览调试，命令： 1hexo server （hexo s 缩写也可以） 开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了 ，可以更换个端口号 然后再执行 hexo s12hexo server -p 5000 #更改端口随意写hexo server -i 192.168.1.1 #自定义 IP运行成功后按Control+L可以停止 如果直接用Hexo s启动会提示错误 就是已经被占用了 所以正确的命令应该是12hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页上边算是搭建了一个本地的博客系统了 然后就是配置Git了用git就可以把博客移动到远程服务器访问类似我的博客地址http://ws1227.github.io配置Github建立Repository建立与你用户名对应的仓库，仓库名必须为【useame.github.io】如下图我的，固定写法 建立关联 打开Blog在本地/Users/wangsen/Blog，Blog是之前建Hexo的文件，有：12345678910Blog ｜ ｜－－ _config.yml ｜－－ node_modules ｜－－ public ｜－－ source ｜－－ db.json ｜－－ package.json ｜－－ scaffolds ｜－－ themes 现在我们需要打开_config.yml文件，来建立关联，命令： 如果终端不是在Blog目录就cd到该目录执行命令 1vim _config.yml 我建议用sublime翻到最下面，改成我这样子的，注意 : 后面要有个空格repository地址换成你自己的git地址1234deploy: type: git repository: https://github.com/ws1227/ws1227.github.io.git branch: master执行如下命令才能使用git部署1npm install hexo-deployer-git –save配置命令：作用就是把blog目录下的Public目录下的文件上传至git仓库1hexo deploy 然后再浏览器中输入就行了http://ws1227.github.io/，我的 github 的账户叫 ws1227 ,把这个改成你 github 的账户名就行了每次修改博客文件后都需要从新部署123hexo cleanhexo generatehexo deploy一些常用命令：http://www.jianshu.com/p/eb02029f7a81HEXO主题 如果你到了这里没有任何问题，那么恭喜你已经成功了，不过这才刚刚开始。当你成功的看到自己博客搭建好的那一刻又是激动又是失望，激动的是博客总算折腾出来了，失望的是，为何如此的丑。。。说实话Hexo默认的主题我不喜欢，如果你想换风格,Hexo的主题网上随便一搜也有很多。在此笔者使用的博客主题是Next.Pisces（国人写的）。https://github.com/iissnan/hexo-theme-next 作者很详细的使用文档域名绑定（第三步，可选）笔者是在万网买的域名（http://wangsen.website/）。 域名买好之后提交实名认证等，这些操作就不在赘述。域名购买地址。价格表：https://wanwang.aliyun.com/help/price.html?spm=5176.8076989.339865.8.yRl9gU选择自己喜欢又能接受价格的域名吧 域名是需要每年都付钱的，看清楚续费价格再下手。买完域名后进入域名管理后台添加解析,下图我添加解析后的。说下这个记录值就是ip地址得获取方式，打开终端ping下自己的git仓库 命令如下格式1ping ws1227.github.io看到如下数据，就看到这个ip地址了123456PING github.map.fastly.net (151.101.100.133): 56 data bytes64 bytes from 151.101.100.133: icmp_seq=0 ttl=50 time=105.119 msRequest timeout for icmp_seq 164 bytes from 151.101.100.133: icmp_seq=2 ttl=50 time=105.448 ms64 bytes from 151.101.100.133: icmp_seq=3 ttl=50 time=104.788 ms64 bytes from 151.101.100.133: icmp_seq=4 ttl=50 time=103.319 ms然后在你的本地站点目录里的source目录下添加一个CNAME文件，不带后缀，可以用终端切换到source目录下，执行命令如下1vim CNAME内容是域名地址不带www和http 就类似我的是 wangsen.website填写完了之后再重新部署到github pages上（部署简写命令hexo d -g)打开自己的博客尽情打开各种蹂躏吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017-03-15-hello-world.html</url>
      <content type="text"><![CDATA[新的一片天]]></content>
    </entry>

    
  
  
</search>
