<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[解决xcode8.2控制台数据打印不全]]></title>
      <url>%2F2017-04-25-%E8%A7%A3%E5%86%B3xcode8-2-NSlog%E6%95%B0%E6%8D%AE%E6%89%93%E5%8D%B0%E4%B8%8D%E5%85%A8.html</url>
      <content type="text"><![CDATA[最近升级Xcode8，开发工具出现了，控制台log数据不完整，经常打印一半，就没有了，经过查询一番终于找到了解决办法! 解决办法：宏定义去log日志数据，把NSlog换成print 123456789#ifdef DEBUG#define DLog( s, ... ) printf(&quot;class: &lt;%p %s:(%d) &gt; method: %s \n%s\n&quot;, self, [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String], __LINE__, __PRETTY_FUNCTION__, [[NSString stringWithFormat:(s), ##__VA_ARGS__] UTF8String] )#else#define DLog( s, ... )#endif 日了狗了 让我纠结半天 ，心想xcode不会出现这么低级的问题吧，没想查了一下还真有这个问题，事实证明‘实践是证明真理的唯一标准’啊。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决TableViewCell和CollectionViewCell复用布局错乱问题]]></title>
      <url>%2F2017-03-30-%E8%A7%A3%E5%86%B3TableViewCell%E5%92%8CCollectionViewCell%E5%A4%8D%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[解决TableViewCell和UICollectionViewCell使用过程中因为重用机制问题造成数据重复显示或者布局错乱问题。 常规配置如下 当超过tableView显示的范围的时候 后面显示的内容将会和前面重复 123456789101112131415161718192021// 这样配置的话超过页面显示的内容会重复出现- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义唯一标识 static NSString *CellIdentifier = @&quot;Cell&quot;; // 通过唯一标识创建cell实例 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125;//通过以下3方案可以解决 方案一： 让每个cell都拥有一个对应的标识 这样做也会让cell无法重用 所以也就不会是重复显示了 显示内容比较多时内存占用也是比较多的 123456789101112131415161718/ /方案一 通过不让他重用cell 来解决重复显示 不同的是每个cell对应一个标识- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义cell标识 每个cell对应一个自己的标识 NSString *CellIdentifier = [NSString stringWithFormat:@&quot;cell%ld%ld&quot;,indexPath.section,indexPath.row]; // 通过不同标识创建cell实例 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125; 方案二： 同样取消cell的重用机制，通过indexPath来创建cell 将可以解决重复显示问题 不过这样做相对于大数据来说内存就比较吃紧了 123456789101112131415161718// 方案二 通过不让他重用cell 来解决重复显示- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义唯一标识 static NSString *CellIdentifier = @&quot;Cell&quot;; // 通过indexPath创建cell实例 每一个cell都是单独的 UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125; ###方案三 只要最后一个显示的cell内容不为空，然后把它的子视图全部删除，等同于把这个cell单独出来了 然后跟新数据就可以解决重复显示 12345678910111213141516171819202122232425// 方案三 当页面拉动需要显示新数据的时候，把最后一个cell进行删除 就有可以自定义cell 此方案即可避免重复显示，又重用了cell相对内存管理来说是最好的方案 前两者相对比较消耗内存- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义唯一标识 static NSString *CellIdentifier = @&quot;Cell&quot;; // 通过唯一标识创建cell实例 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; else//当页面拉动的时候 当cell存在并且最后一个存在 把它进行删除就出来一个独特的cell我们在进行数据配置即可避免 &#123; while ([cell.contentView.subviews lastObject] != nil) &#123; [(UIView *)[cell.contentView.subviews lastObject] removeFromSuperview]; &#125; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125; 经过测试UIcollectionViewCell布局错乱用第一种方法同样可以解决问题，实际解决情况还要自己测试才可以。 最后贴一个我的UIcollectionViewCell解决复用的代码 123456789101112- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; NSString *CellIdentifier = [NSString stringWithFormat:@&quot;cell%ld%ld&quot;,indexPath.section,indexPath.row]; [self.collectionView registerNib:[UINib nibWithNibName:@&quot;AudienceViewCollectionViewCell&quot; bundle:nil] forCellWithReuseIdentifier:CellIdentifier]; // 通过不同标识创建cell实例 AudienceViewCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:CellIdentifier forIndexPath:indexPath]; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift函数与闭包的应用实例]]></title>
      <url>%2F2017-03-29-Swift%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B.html</url>
      <content type="text"><![CDATA[今天的博客算是比较基础的，还是那句话，基础这东西在什么时候都是最重要的。说到函数，只要是写过程序就肯定知道函数是怎么回事，今天就来讨论一下Swift中的函数的特性以及Swift中的闭包。今天的一些小实例中回类比一下Objective-C中的函数的写法等等。Swift中的函数还是有许多好用的特性的，比如输入参数，使用元组返回多个值， 定义形参名，设定默认参数以及可变参数等等一些好用的特性。而在Swift中的闭包就是Objective-C中的Block, 除了语法不通外，两者的用法是一样的。废话少说，开始今天的主题，先搞一搞Swift中的函数，然后在搞一搞Swift中的闭包。 一.Swift中的函数 1. 函数的定义与使用 在介绍Swift中的函数之前，我想用Objective-C中的一个简单的加法函数来作为引子，然后类比着实现一下Swift中相同功能的函数。关于函数定义就比较简单了，就是一些语法的东西，下面的代码片段是Objc中求两个整数之和的函数，并返回两个数的和。- (NSInteger)sumNumber1:(NSInteger) number1 number2:(NSInteger) number2 { return number1 + number2;} 函数的功能比较简单了，就是把两个整数传进来，然后返回两个整数的和。接下来将用Swift语言实现，也好通过这个实例来熟悉一下Swift语言中定义函数的语法。下方是Swift语言中求两个整数之和的函数。语法比较简单了，在Swift中定义函数，我们会使用到关键字func来声明函数。1 //函数定义2 func sum (number1:Int, number2:Int) -&gt; Int{3 return number1 + number2;4 } 用文字来描述Swift定义基本函数的语法就是: func 函数名 （形参列表） -&gt; 返回值类型 { 函数体}，这样你就可以定义一个函数了。当然，函数定义时还有好多其他的用法，下面会详细介绍。上面函数的调用方法如下：1 let sumTwoNubmer = sum(2, number2: 3);&nbsp; 2. 函数中的形参列表 关于函数中的形参列表还是有必要提上一嘴的，因为形参列表作为函数数据源之一，所以把参数列表好好的搞一搞还是很有必要的。参数列表也有很多好用的使用方式，接下来详细的介绍一下函数的形参列表。 (1) 默认的形参是常量（let） 在函数的形参列表中，默认的形参是常量。也就是相当于用let关键字对形参进行修饰了。我们可以做个试验，把上面加法函数做一个修改，在加法函数中对number1进行加1操作，你会得到一个错误，这个错误的大体意思就是&ldquo;number1是不可被修改的，因为它是let类型的常量&rdquo;。并且编译器还给人出了Fix-it（修复）的方案，就是在number1前面使用var关键字进行修饰，使其成为变量，这样才可以修改其值。 上面说这么多，一句话：形参默认是常量，如果你想让其是变量，那么你可以使用var关键字进行修饰，这样被关键字var修饰的变量在函数中就可以被修改。下方就是报的这个错误，和编译器提供的解决方案。（在Objc中默认可以在函数中改变形参的值）&nbsp; （2）给形参命名 为了代码的可读性和可维护性，我们在定义函数时，需要为每个参数名一个名字，这样调用者见名知意，很容易就知道这个参数代表什么意思了。接下来还是在上述加法函数中进行修改，为每个参数名一个名字，并看一下调用方式。修改上面的函数，给第一个形参命名成numberOne, 第二个形参为numberTwo, 下方是修改后的函数。 紧接着sum()函数的调用方式也会有所改变，在调用函数时编译器会给出参数的名称，这样调用者一目了然。1 //函数定义2 func sum (numberOne number1:Int, numberTwo number2:Int) -&gt; Int{3 return number1 + number2;4 }56 let sumTwoNubmer = sum(numberOne: 10, numberTwo: 20); &nbsp;调用上述函数时，下方是编译器给出的提示，一目了然呢。 关于Swift中参数名的内容，要说明的是在Swift1.0的时候，你可以在参数前面添加上#号，然后参数名就与变量（或者常量）的名字相同，而Swift2.0后这个东西去掉了，因为默认就相当于Swift1.0中添加#号。&nbsp; (3) 函数的传参与传引用 先暂且这么说着，在C语言的函数中可以给函数传入参数，或者传入实参的内存地址就是所谓的传引用。如果传入的是引用的话，在函数中对值进行修改的话，那么出了函数，这个被修改的值是可以被保留的。在Swift中也是可以的，不过你需要使用inout关键字修饰形参，并且在使用该函数时，用&amp;来修饰。这一点和C语言中类似，&amp;就是取地址符。下方是inout使用的一个小实例。1 func incrementStepTwo (inout myNumber:Int) {2 myNumber += 23 }4 var myTestNumber = 65 incrementStepTow(&amp;myTestNumber) //myTestNumber = 8 myTestNumber变量经过incrementStepTwo()函数后，其值就会增加2。当然前提是myTestNumber是变量，如果myTestNumber是常量的话，那么对不起，调用该函数就会报错，下面是把var改成let后IDE给的错误提示。错误原因很显然是你动了一个不该动的值，也就是常量不可再次被修改的。&nbsp; (4) 不定参数函数 不定参数函数也就是形参的个数是不定的，但是形参的类型必须是相同的。不定形参在使用时怎么取呢？不定个数的形参实际上是一个数组，我们可以通过for循环的形式来遍历出每个形参的值，然后使用就可以了。下方incrementMultableAdd()函数的形参的个数是不定的，其功能是求多个整数的和。在函数中我们只需遍历每个参数，然后把每个参数进行相加，最后返回所求的和即可。函数比较简单，再此就不在啰嗦了。&nbsp; (5) 默认形参值 在Swift语言中是支持给形参赋初始值的，这一点在其他一些编程语言中也是支持的。但是Objective-C这么看似古老的语言中就不支持给形参指定初始值，在Swift这门现代编程语言中是支持这一特性的。默认参数要从参数列表后开始为参数指定默认值，不然就会报错。下方就是为函数的形参指定默认参数的示例。一个表白的方法sayLove(), 形参youName默认是&ldquo;山伯&rdquo;， 形参loverName默认是&ldquo;英台&rdquo;。 紧接着是sayLove函数的三种不同的调用方式，在调用函数时你可以不传参数，可以传一个参数，当然传两个也是没问题的。&nbsp; 因为函数的每个参数都是有名字的，在含有默认参数的函数调用时，可以给任意一个参数进行传值，其他参数取默认值，这也是Swift的一大特色之一，具体请看如下简单的代码示例：&nbsp; 3.函数类型 每个函数都有自己的所属类型，函数类型说白了就是如果两个函数参数列表相同以及返回值类型相同，那么这两个函数就有着相同的函数类型。在Swift中可以定义一个变量或者常量来存储一个函数的类型。接下来将用过一个实例还介绍一下函数类型是个什么东西。 &nbsp; (1) 首先创建两个函数类型相同的函数，一个函数返回两个整数的差值，另一个函数返回两个整数的乘积。当然这两个函数比较简单，直接上代码：1 //现定义两个函数类型相同的函数2 func diff (number1:Int, number2:Int) -&gt; Int {3 return number1 - number2;4 }56 func mul (number1:Int, number2:Int) -&gt; Int {7 return number1 number2;8 } (2) 函数定义好后，接着要定义个一个枚举来枚举每种函数的类型，下面定义这个枚举在选择函数时会用到，枚举定义如下：1 //定义两种计算的枚举类型2 enum CountType:Int {3 case DiffCount = 04 case MulCount5 } (3) 接下来就是把(1)和(2)中定义的东西通过一个函数来组合起来。说白了，就是定义个函数来通过枚举值返回这个枚举值所对应的函数类型。有时候说多了容易犯迷糊，就直接上代码得了。下方函数的功能就是根据传进来的枚举值来返回相应的函数类型。 1 //选择类型的函数，并返回相应的函数类型 2 func choiseCountType(countType:CountType) -&gt; ((Int, Int) -&gt; Int) { 3 //函数类型变量 4 var myFuncType:(Int, Int) -&gt; Int 5 6 switch countType { 7 case .DiffCount: 8 myFuncType = diff 9 case .MulCount:10 myFuncType = mul11 }12 return myFuncType;13 } (4) 接下来就是使用(3)中定义的函数了，首先我们需要定义一个相应函数类型((Int, Int) -&gt; Int)的变量来接收choiseCountType()函数中返回的函数类型，然后调用该函数类型变量，在Playground中执行的结果如下：&nbsp; &nbsp; &nbsp;4.函数嵌套 我们可以把 3 中的代码使用函数嵌套进行重写，在Swift中是支持函数嵌套的。 所以可以吧3.1和3.2中的函数放到3.3函数中的，所以我们可以对上述代码使用函数嵌套进行重写。使用函数嵌套重写后的代码如下所示，当然，choiseCountType()函数的调用方式没用发生改变，重写后的调用方式和3.4中的调用方式是一样一样的。 1 //选择类型的函数，并返回相应的函数类型 2 func choiseCountType(countType:CountType) -&gt; ((Int, Int) -&gt; Int) { 3 4 //现定义两个函数类型相同的函数 5 func diff (number1:Int, number2:Int) -&gt; Int { 6 return number1 - number2; 7 } 8 9 func mul (number1:Int, number2:Int) -&gt; Int {10 return number1 number2;11 }121314 //函数类型变量15 var myFuncType:(Int, Int) -&gt; Int1617 switch countType {18 case .DiffCount:19 myFuncType = diff20 case .MulCount:21 myFuncType = mul22 }23 return myFuncType;24 }&nbsp; 二. 闭包 说道Swift中的闭包呢，不得不提的就是Objective-C中的Block, 其实两者是一个东西，使用方式以及使用场景都是相同的。我们完全可以类比着Objective-C中的Block来介绍一下Swift中的Closure（闭包）。其实就是匿名函数。接下来的这段内容，先介绍一下Swift中Closure的基本语法，然后在类比着ObjC中的Block窥探一下Closure的使用场景。 1.Closure变量的声明 Closure就是匿名函数，我们可以定义一个闭包变量，而这个闭包变量的类型就是我们上面介绍的&ldquo;函数类型&rdquo;。定义一个闭包变量其实就是定义一个特定函数类型的变量，方式如下。因为Closure变量没有赋初始值，所以我们把其声明为可选类型的变量。在使用时，用!强制打开即可。1 var myCloure0:((Int, Int) -&gt; Int)? 除了上面的方式外，我们还用另一种常用的声明闭包变量的方式。那就是使用关键字typealias定义一个特定函数类型，我们就可以拿着这个类型去声明一个Closure变量了，如下所示1 //定义闭包类型 (就是一个函数类型)2 typealias MyClosureType = (Int, Int) -&gt; Int3 var myCloure:MyClosureType?&nbsp; 2. 给Closure变量赋值 给Closure变量赋值，其实就是把一个函数体赋值给一个函数类型的变量，和函数的定义区别不大。但是给闭包变量赋值的函数体中含有参数列表，并且参数列表和真正的函数体之间使用关键字in来分割。 闭包可选变量的调用方式与普通函数没什么两样，唯一不同的是这个函数需要用!来强制打开才可以使用。赋值和调用方式如下。&nbsp; 3. 闭包回调的应用实例 暂且先称作闭包回调吧，其实就是Objc中的Block回调。在Swift中的闭包回调和Objc中的Block回调用法一致，下方将会通过一个实例来介绍一下闭包的应用之一。下方会创建两个视图控制器，我们暂且称为FirstViewController和SecondViewController。在FirstViewController上有一个Label和一个Button, 这个Button用来跳转到SecondViewController, 而这个Label用来显示从SecondViewController中回调过来的值。 而SecondViewController也有一个TextField和一个Button, 点击Button就会把输入框中的值通过闭包回调回传到FirstViewController然后在FirstViewController上的Label显示。 (1) 构建这个实例的第一步要做的就是使用Stroyboard把我们所需的控件布局好，并且管理相应的类。当然我们这个Demo的重点不在于如何去布局控件，如何去关联控件，以及如何去使用控件，所以上述的这些就不做赘述了。这个实例的重点在于如何使用Closure实现值的回调。下方是我们的控件布局和目录结构的截图，从Storyboard上的控件来看，功能也就一目了然了。点击&ldquo;FirstViewController&rdquo; 上的&ldquo;Go SecondViewController&rdquo;按钮，就会跳转到 &ldquo;SecondViewController&rdquo; 。 在SecondViewController视图上的输入框输入数值，点击Back按钮返回到FirstViewController, 同时把输入框中的文本通过闭包回调的形式回传过来在FristViewController的label上显示。大致就这个简单的功能。&nbsp; （2）FirstViewController.swift中的内容 FirstViewController.swift中的内容比较简单，就关联一个Label控件和一个按钮点击的事件，点击按钮就会跳转到SecondViewController，具体代码如下，在此就不啰嗦了，请看代码中的注释。下方代码重要的一点是在跳转到SecondViewController时要实现其提供的闭包回调，以便接受回传过来的值。 1 // 2 // FirstViewController.swift 3 // SwiftDemo 4 // 5 // Created by Mr.LuDashi on 15/11/18. 6 // Copyright &copy; 2015年 ZeluLi. All rights reserved. 7 // 8 9 import UIKit1011 class FirstViewController: UIViewController {1213 @IBOutlet var showTextLabel: UILabel! //展示回调过来的文字信息1415 override func viewDidLoad() {16 super.viewDidLoad()17 }1819 override func didReceiveMemoryWarning() {20 super.didReceiveMemoryWarning()21 }2223 //点击按钮跳转到SecondViewController24 @IBAction func tapGoSecondViewControllerButton(sender: UIButton) {25 //从Storyboard上加载SecondViewController26 let secondVC = UIStoryboard(name: “Main”, bundle: NSBundle.mainBundle()).instantiateViewControllerWithIdentifier(“SecondViewController”)as! SecondViewController2728 //实现回调，接收回调过来的值29 secondVC.setBackMyClosure { (inputText:String) -&gt; Void in30 self.showTextLabel.text = inputText31 }3233 //push到SecondViewController34 self.navigationController?.pushViewController(secondVC, animated: true)35 }36 }&nbsp; (3) SecondViewController.swift中的内容 SecondViewController.swift中的内容也不麻烦，就是除了关联控件和事件外，还定义了一个闭包类型（函数类型），然后使用这个特定的函数类型声明了一个此函数类型对应的变量。我们可以通过这个变量来接受上个页面传过来的闭包体，从而把用户输入的值，通过这个闭包体回传到上个页面。具体代码实现如下： 1 // 2 // SecondViewController.swift 3 // SwiftDemo 4 // 5 // Created by Mr.LuDashi on 15/11/18. 6 // Copyright &copy; 2015年 ZeluLi. All rights reserved. 7 // 8 9 import UIKit1011 typealias InputClosureType = (String) -&gt; Void //定义闭包类型（特定的函数类型函数类型）1213 class SecondViewController: UIViewController {1415 @IBOutlet var inputTextField: UITextField! //输入框，让用户输入值，然后通过闭包回调到上一个页面1617 var backClosure:InputClosureType? //接收上个页面穿过来的闭包块1819 override func viewDidLoad() {20 super.viewDidLoad()21 }2223 override func didReceiveMemoryWarning() {24 super.didReceiveMemoryWarning()25 }2627 //闭包变量的Seter方法28 func setBackMyClosure(tempClosure:InputClosureType) {29 self.backClosure = tempClosure30 }3132 @IBAction func tapBackButton(sender: UIButton) {33 if self.backClosure != nil {34 let tempString:String? = self.inputTextField.text35 if tempString != nil {36 self.backClosure!(tempString!)37 }38 }39 self.navigationController!.popViewControllerAnimated(true)40 }41 }&nbsp; (4) 经过上面的步骤这个实例已经完成，接下来就是看一下运行效果的时间了。本来想做成Git动态图的，感觉实例功能简单，而且UI上也比较简单，就没做，还是看截图吧。运行效果的截图如下： 4.数组中常用的闭包函数 在Swift的数组中自带了一些比较好用的闭包函数，例如Map, Filter, Reduce。接下来就好好的看一下这些闭包，用起来还是比较爽的。 (1) Map(映射) 说到Map的用法和功能，不能不说的是如果你使用过ReactiveCocoa框架，那么对里边的Sequence中的Map的使用方式并不陌生。其实两者的使用方法和功能是极为相似的。如果你没使用过RAC中的Map，那也无关紧要，接下来我们先上段代码开看一下数组中的Map闭包函数。 通过上面的代码段以及运行结果，我们不难看出，map闭包函数的功能就是对数组中的每一项进行遍历，然后通过映射规则对数组中的每一项进行处理，最终的返回结果是处理后的数组（以一个新的数组形式出现）。当然，原来数组中的元素值是保持不变的，这就是map闭包函数的用法与功能。&nbsp;&nbsp; (2) Filter (过滤器) Filter的用法还是比较好理解的，Filter就是一个漏勺，就是用来过滤符合条件的数据的。在ReactiveCocoa中的Sequence也是有Filter的，用法还是来过滤Sequence中的数据的。而在数组中的Filter用来过滤数组中的数据，并且返回新的数组，新的数组中存放的就是符合条件的数据。Filter的用法如下实例，下方的实例就是一个身高的过滤，过滤掉身高小于173的人，返回大于等于173的身高数据。 （3）Reduce&nbsp; 在ReactiveCocoa中也是有Reduce这个概念的，ReactiveCocoa中使用Reduce来合并消减信号量。在swift的数组中使用Reduce闭包函数来合并items, 并且合并后的Value。下方的实例是一个Salary的数组，其中存放的是每个月的薪水。我们要使用Reduce闭包函数来计算总的薪水。下方是DEMO的截图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift字符串常用操作]]></title>
      <url>%2F2017-03-28-Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html</url>
      <content type="text"><![CDATA[swift 中关于取子串有4 个方法 str.index(after: String.Index) str.index(before: String.Index) str.index(String.Index, offsetBy: String.IndexDistance) str.index(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index) 分别是什么, 该如何使用?下面来看看本例中, 我们创建一个字符串"Hello, playground" , 如下 var str = "Hello, playground" 字符索引 startIndex 和 endIndex startIndex 是第一个字符的索引, 也就是 endIndex 是最后一个字符索引 +1 // character str[str.startIndex] // H str[str.endIndex] // error: after last character // range let range = str.startIndex ..&lt; str.endIndex str[range] // "Hello, playground" after index(after: String.Index)after 指向给定索引后面的一个索引(类似与 + 1) // character let index = str.index(after: str.startIndex) str[index] // "e" // range let range = str.index(after: str.startIndex)..&lt;str.endIndex str[range] // "ello, playground" before index(before: String.Index)before 指向给定索引之前的一个索引(类似与 - 1) // character let index = str.index(before: str.endIndex) str[index] // d // range let range = str.startIndex ..&lt; str.index(before: str.endIndex) str[range] // Hello, playgroun offsetBy index(String.Index, offsetBy: String.IndexDistance)offsetBy 的值可以为正或是负, 正则表示向后, 负则相反.别被offsetBy 的 String.IndexDistance 类型吓到, 本身其实是一个 Int.(类似于+n 和 -n) // characterlet index = str.index(str.startIndex, offsetBy: 7)str[index] // p // rangelet start = str.index(str.startIndex, offsetBy: 7)let end = str.index(str.endIndex, offsetBy: -6)let range = start ..&lt; endstr[range] // play limitedBy index(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index) limitedBy 在 offset 过大导致溢出错误的时候很有用.这个返回值是一个可选值, 如果 offsetBy 超过了 limitBy, 则返回 nil. // characterif let index = str.index(str.startIndex, offsetBy: 7, limitedBy: str.endIndex) {str[index] // p} 上面这段代码中如果offset 设置为 77, 返回值就是 nil, if 中的代码就会跳过 所以如果你要取子串的正确姿势是什么? 取某个位置之后的所有字符str.substring(from: str.index(str.startIndex, offsetBy: 7)) // playground取倒数某个位置之后的所有字符str.substring(from: str.index(str.endIndex, offsetBy: -10)) //playground取某个位置之前的所有字符str.substring(to: str.index(str.startIndex, offsetBy: 5)) //Hello取倒数某个位置之前的所有字符str.substring(to: str.index(str.endIndex, offsetBy: -12)) //Hello取中间的某个字符串str.substring(with: str.index(str.startIndex, offsetBy: 7) ..&lt; str.index(str.endIndex, offsetBy: -6)) // play]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo配合github搭建免费博客，绑定域名]]></title>
      <url>%2F2017-03-15-Hexo%E9%85%8D%E5%90%88github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D.html</url>
      <content type="text"><![CDATA[出发点：有那么大的博客平台不用为什么自己搭建博客，说白了就是玩玩坚持写几篇博客然后就是装逼了呗。本篇文章在我的简书地址今天要讲的搭建博客教程很简单不需要什么钱当然有钱可以买虚拟机配个数据库可以玩wordpress搭建博客更简单，记得万网有活动几块钱就可以买个一年的虚拟机活动长期有可以看看，这里就不详细介绍了。言归正传，本篇博客说的是用github和 Hexo搭建一个免费的博客网站，搭建完看起来像这样 http://ws1227.github.io 如果有个人域名就可以类似这样http://wangsen.website/ 后边再介绍。 先说下需要的基本条件：安装Node（必须） 作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。提供一个mac版本的https://pan.baidu.com/s/1gf5NSyf 不用翻墙下载了安装Git（必须）作用：把本地的hexo内容提交到github上去. 安装Xcode就自带有Git，我就不多说了。没有的话可以去https://git-scm.com/downloads 下载申请GitHub（必须）作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。安装HexoNode和Git都安装好后，可执行如下命令安装hexo：1$ sudo npm install -g hexo创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：1hexo init好啦，至此，全部安装工作已经完成！因为Hexo编写的文章都是用 markdown语法写的 所以需要生成静态界面也就是Html网页。 生成静态页面继续在刚才的Blog目录下执行如下命令，生成静态页面 1hexo generate （hexo g 缩写也可以） 本地启动启动本地服务，进行文章预览调试，命令： 1hexo server （hexo s 缩写也可以） 开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了 ，可以更换个端口号 然后再执行 hexo s12hexo server -p 5000 #更改端口随意写hexo server -i 192.168.1.1 #自定义 IP运行成功后按Control+L可以停止 如果直接用Hexo s启动会提示错误 就是已经被占用了 所以正确的命令应该是12hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页上边算是搭建了一个本地的博客系统了 然后就是配置Git了用git就可以把博客移动到远程服务器访问类似我的博客地址http://ws1227.github.io配置Github建立Repository建立与你用户名对应的仓库，仓库名必须为【useame.github.io】如下图我的，固定写法 建立关联 打开Blog在本地/Users/wangsen/Blog，Blog是之前建Hexo的文件，有：12345678910Blog ｜ ｜－－ _config.yml ｜－－ node_modules ｜－－ public ｜－－ source ｜－－ db.json ｜－－ package.json ｜－－ scaffolds ｜－－ themes 现在我们需要打开_config.yml文件，来建立关联，命令： 如果终端不是在Blog目录就cd到该目录执行命令 1vim _config.yml 我建议用sublime翻到最下面，改成我这样子的，注意 : 后面要有个空格repository地址换成你自己的git地址1234deploy: type: git repository: https://github.com/ws1227/ws1227.github.io.git branch: master执行如下命令才能使用git部署1npm install hexo-deployer-git –save配置命令：作用就是把blog目录下的Public目录下的文件上传至git仓库1hexo deploy 然后再浏览器中输入就行了http://ws1227.github.io/，我的 github 的账户叫 ws1227 ,把这个改成你 github 的账户名就行了每次修改博客文件后都需要从新部署123hexo cleanhexo generatehexo deploy一些常用命令：http://www.jianshu.com/p/eb02029f7a81HEXO主题 如果你到了这里没有任何问题，那么恭喜你已经成功了，不过这才刚刚开始。当你成功的看到自己博客搭建好的那一刻又是激动又是失望，激动的是博客总算折腾出来了，失望的是，为何如此的丑。。。说实话Hexo默认的主题我不喜欢，如果你想换风格,Hexo的主题网上随便一搜也有很多。在此笔者使用的博客主题是Next.Pisces（国人写的）。https://github.com/iissnan/hexo-theme-next 作者很详细的使用文档域名绑定（第三步，可选）笔者是在万网买的域名（http://wangsen.website/）。 域名买好之后提交实名认证等，这些操作就不在赘述。域名购买地址。价格表：https://wanwang.aliyun.com/help/price.html?spm=5176.8076989.339865.8.yRl9gU选择自己喜欢又能接受价格的域名吧 域名是需要每年都付钱的，看清楚续费价格再下手。买完域名后进入域名管理后台添加解析,下图我添加解析后的。说下这个记录值就是ip地址得获取方式，打开终端ping下自己的git仓库 命令如下格式1ping ws1227.github.io看到如下数据，就看到这个ip地址了123456PING github.map.fastly.net (151.101.100.133): 56 data bytes64 bytes from 151.101.100.133: icmp_seq=0 ttl=50 time=105.119 msRequest timeout for icmp_seq 164 bytes from 151.101.100.133: icmp_seq=2 ttl=50 time=105.448 ms64 bytes from 151.101.100.133: icmp_seq=3 ttl=50 time=104.788 ms64 bytes from 151.101.100.133: icmp_seq=4 ttl=50 time=103.319 ms然后在你的本地站点目录里的source目录下添加一个CNAME文件，不带后缀，可以用终端切换到source目录下，执行命令如下1vim CNAME内容是域名地址不带www和http 就类似我的是 wangsen.website填写完了之后再重新部署到github pages上（部署简写命令hexo d -g)打开自己的博客尽情打开各种蹂躏吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017-03-15-hello-world.html</url>
      <content type="text"><![CDATA[新的一片天]]></content>
    </entry>

    
  
  
</search>
