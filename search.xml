<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[AFNetworking和Alamofire设置跳过https(SSL)验证]]></title>
      <url>%2F2017-07-07-AFNetworking%E5%92%8CAlamofire%E8%AE%BE%E7%BD%AE%E8%B7%B3%E8%BF%87https(SSL)%E9%AA%8C%E8%AF%81.html</url>
      <content type="text"><![CDATA[我们服务器用的是https但是没用证书，客户端不验证，在ios11之前是不用做处理的，在下载了ios11之后发现请求失败了，就是证书验证失败，想必是这次版本更新的一点小变化吧。 现在项目用的是AFNetworking 3.0.2版本报错 Error Domain=NSURLErrorDomain Code=-999 “已取消” 然后换了swift的Alamofire请求报错是 Domain=NSURLErrorDomain Code=-1202 “The certificate for this server is invalid. You might be connecting to a server that is pretending to be “api.domain.cn” which could put your confidential information at risk.” UserInfo={NSURLErrorFailingURLPeerTrustErrorKey=, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9807…. 总之就是证书的问题了，我们服务器是没有验证证书的 所以需要前端这边声明跳过验证的 网上查了下找到了如下解决办法 OC的代码如下 123456AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO// 如果是需要验证自建证书，需要设置为YESsecurityPolicy.allowInvalidCertificates = YES;[securityPolicy setValidatesDomainName:NO];[manger setSecurityPolicy:securityPolicy]; Swift用Alamofire解决方案 12345678910111213public func defaultAlamofireManager() -&gt; Manager &#123; let configuration = URLSessionConfiguration.default configuration.httpAdditionalHeaders = Alamofire.SessionManager.defaultHTTPHeaders let policies: [String: ServerTrustPolicy] = [ &quot;api.domian.cn&quot;: .disableEvaluation ] let manager = Alamofire.SessionManager(configuration: configuration,serverTrustPolicyManager: ServerTrustPolicyManager(policies: policies)) manager.startRequestsImmediately = false return manager&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用DZNEmptyDataSet时DZNEmptyDataSetView自动上移]]></title>
      <url>%2F2017-07-05-%E4%BD%BF%E7%94%A8DZNEmptyDataSet%E6%97%B6DZNEmptyDataSetView%E8%87%AA%E5%8A%A8%E4%B8%8A%E7%A7%BB.html</url>
      <content type="text"><![CDATA[使用DZNEmptyDataSet遇到的一个问题 今天在使用DZNEmptyDataSet遇到了一个问题，就是我用MJRefresh 后DZNEmptyDataSet View的整个背景尺寸不对。ps: DZNEmptyDataSet是一个相当不错设置空白页面的轮子非常 好使 。 无论是用自定义 1- (UIView *)customViewForEmptyDataSet:(UIScrollView *)scrollView 还是直接用 DZNEmptyDataSet 推荐的方式直接设置都是有问题的 123- (UIImage *)imageForEmptyDataSet:(UIScrollView *)scrollView;- (NSAttributedString *)descriptionForEmptyDataSet:(UIScrollView *)scrollView- (NSAttributedString *)buttonTitleForEmptyDataSet:(UIScrollView *)scrollView forState:(UIControlState)state 看看问题的具体表现吧 下边这个就是 有问题了，没数据后自动上移了 简单的说问题是：刷新后DZNEmptyDataSetView 还会向上偏移一段距离！尝试各种刷新都没有用 12[self.tableView reloadEmptyDataSet]; [self.tableView reloadData]; 看了下视图的层次关系可以看出了DZNEmptyDataSetView上移了54，然后我一搜 54 ，发现54出现地方并不多，结合刷新猜测应该就是它啦 1const CGFloat MJRefreshHeaderHeight = 54.0; 所以推测，DZNEmptyDataSetView是根据正在刷新的过程中给其定布局的。然而我们需要阻止它或延后它。 此处我是想着在这之后直接处理它,改变它的 origin。 123456for (UIView *subView in self.tableView.subviews) &#123;if ([NSStringFromClass([subView class]) isEqualToString:@&quot;DZNEmptyDataSetView&quot;])&#123;if (subView.frame.origin.y == 0) return;subView.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height - 64);&#125;&#125; 在刷新后这样处理，方法有点死，但是相对来说比较直接的。 从 github 上看到的方法如下，貌似是目前使用最合理的吧，有其他方法欢迎告知。 123- (void)emptyDataSetWillAppear:(UIScrollView *)scrollView &#123;scrollView.contentOffset = CGPointZero;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何使用iOS 9的Core Spotlight框架]]></title>
      <url>%2F2017-05-25-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8iOS%209%E7%9A%84Core%20Spotlight%E6%A1%86%E6%9E%B6.html</url>
      <content type="text"><![CDATA[iOS每一次版本的更新，都会给全球的开发工作者带来新的“知识点”和对现有技术进行的改进。显然，iOS的最新版本iOS 9不仅延续了这一传统，还公布了新的框架和API，开发者可使用新增的框架和API让自己的应用表现的更出色。其中之一就是Core Spotlight框架，它包含了一些优秀的API，有待开发者深入探究。 Core Spotlight (CS) 框架是Search API的一部分，它增加了开发者的应用的曝光率，使用户更容易发现和访问APP，但是这些API在iOS9之前的版本中是不可用的。这些Search API拉近了用户和app的距离，用户可以通过这种新的方法迅速的找到app,而app也可以迅速的对用户的操作做出反应。除了Core Spotlight之外，iOS 9还包含以下新的search功能（仅供参考）： 1、NSUserActivity这个类中新的方法和属性（该类负责存储app关闭时的状态，以便之后恢复app的状态。） 2、在设备上使用web标记，以便搜索到web中的内容。 3、能通过web内容中的链接直接启动应用程序的通用链接。 本文不会对以上三点做详细介绍，只详细讲解Core Spotlight框架。在讲解之前，先了解以下Core Spotlight到底是什么？ 如上图所示： Core Spotling框架 可以让用户通过Spotlight搜索到app中的数据，并将app相关内容和系统搜索返回的结果一起展示出来。也就是说用户可以与应用程序的其他相关结果进行交互，当点击其中一项搜索结果时并不仅仅自动启动APP，开发者也可以让用户选择与数据最相关的内容。 从开发者的角度来说，集成Core Spotlight框架并使用它提供的API并不是一件难事。学过这教程之后，你将会发现仅仅需要几行代码就可以实现这个功能。集成的核心问题在于开发者必须把APP的数据以特定的格式加入到iOS系统的索引中。 由于本教程专注于Core Spotlight框架的使用，所以我不打算深入研究这个框架。 关于Demo App 和往常一样，我们打算通过一个示例应用来研究探索Spotlight的细节。在这个demo中，我们将往应用程序中写入一组数据，并且这些数据都是可以通过真机或模拟器的Spotlight功能被搜索到的。虽然实现Spotlight功能搜索是重点,但是还是有必要介绍一下关于demo app 的更多细节。 我们的示例应用要达到的效果是展示一些电影及其相关的信息，例如电影概要、导演、明星以及影评等级等。所有的电影数据将会放在列表中展示，并且当点击到对应的行时，所选择的电影会在一个新的视图控制器中展示出电影的详情。这些功能和数据作为我们挖掘Spotlight的API而言已经够用了。我们的数据来源是International Movie Database (IMDB)，我们从这个网站获得数据示例。 通过看下面的动画示例，你可以先看一下演示程序的效果： 在本教程中，我们有两个目的：最重要的是让这个应用内的所有电影方面的数据都可以被Spotlight搜索到。当用户通过关键字搜索时，应用程序内关于电影的数据将会展现给用户。设置这些关键字是我们接下来工作的一部分，我们必须重新定义它们，使之符合规则。 点击搜索结果会打开应用程序，之后我们要实现第二个目标。如果我们没有做任何的处理，那么将会加载包含有电影数据列表的默认视图控制器展示给用户。然而，假如我们考虑到用户体验的话，这么处理并不是很好。好的方案是，我们的APP应该展示Spotlight选中的电影的详情。简言之，我们不仅要让应用程序内的电影数据能够通过Spotlight被搜索到，而且还要在用户点击搜索结果时，展示关联的电影详情页。接下来的示例动画会讲解的更清楚： 为了节约时间，你可以在这里下载工程，然后开始我们的工作。在工程里面你会发现如下所示的内容： 界面部分的组件已经搭建完成，并且包含所有必要的IBOutlet属性。 最小化的列表视图。 所有的电影数据都存放在以plist为后缀的文件中。此外图片文件是和电影一一对应的（一共有5部）。 假使你想知道预先准备的文件中包含了哪些对应电影的数据，那么你可以通过这个截图示例看到所有包含的内容。 先看一下Core Spotlight API的具体信息，我们会处理下面两个任务： 1、在列表中加载和展示电影数据。 2、在选中电影数据列表的某一行时会跳转到对应的电影详情界面。 启动项目没有实现上边的内容，尽管那样么做会让你们快速进到我们的话题，原因很简单：我很确信通过演示应用程序的核心功能和数据样本，你会很容易地了解到将要被Spotlight搜索到的具体数据。但是别担心，因为所有准备工作花费的时间很少，并且很快就可完成。 加载和展示示例数据 假如此时你已经下载好了起始工程，并且已经看过了电影数据属性列表，那么就让我们开始Coding吧。在MoviesData.plist这个文件夹下，你可以看到一共有5条数据，这些数据是从IMDB网站上随机选取的他们对应5个电影示例。我们第一步是从plist文件中加载数据到一个数组中，然后在列表中展示他们。 废话少说，直接上代码。打开ViewController.swift这个文件，并且在这个类声明属性的地方这么写： var moviesInfo: NSMutableArray! 所有的电影模型数据都会被加载到moviesInfo可变数组中，单个电影模型的数据将会以键值对的方式保存在字典中，并且他们和文件中的属性列表相匹配。 现在让我们编写一个加载数据的自定义函数。接下来你会看到，我们只是确保属性列表文件是否存在，如果存在，我们就初始化数组的文件内容： func loadMoviesInfo() { if let path = NSBundle.mainBundle().pathForResource(&quot;MoviesData&quot;, ofType: &quot;plist&quot;) { moviesInfo = NSMutableArray(contentsOfFile: path) }} 接下来我们需要在viewDidLoad()函数调用loadMoviesInfo（）函数。只是为了确保你在调用configureTableView()函数前正确调用此函数，下面展示的是代码片段： override func viewDidLoad() { super.viewDidLoad() // Load the movies data from the file. loadMoviesInfo() configureTableView() navigationItem.title = &quot;Movies&quot;} 要注意的是，我们只需把文件内容加载到viewDidLoad()函数，而不是为了创建上述的loadMoviesInfo()函数，但是作为喜欢代码整洁的人，即便是这么小的事情，都会选择更好的方式来实现。 应用程序每次启动时都会加载这些电影数据，我们可以继续修改当前视图列表，让它显示电影信息。需要处理的只有这么多：根据电影数据信息定义列表的行数，然后在表视图的单元格中展示正确的电影数据。 从列表视图的行数开始，显然列表视图的行数等于电影的数目。然而，我们不应忘记，要确保列表视图中有电影数据展示出来，否则当文件内容不被加载到数组中时就会造成应用程序的崩溃。 func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { if moviesInfo != nil { return moviesInfo.count } return 0} 最后，让我们展示电影数据。为了达到我们需要的目标，在开始准备的工程中你可以找到UITableViewCell的子类MovieSummaryCell，和代表一个电影单元格的.xib文件： 用这样的一个单元格来展示每个电影的图片、标题、部分的描述信息和电影评级。所有UI控件已经连接到IBOutlet属性，并且可以在MovieSummaryCell.swift这个文件找到对应属性的名称： @IBOutlet weak var imgMovieImage: UIImageView!@IBOutlet weak var lblTitle: UILabel!@IBOutlet weak var lblDescription: UILabel!@IBOutlet weak var lblRating: UILabel! 上面的名字代表各个属性的用途，现在我们已经能够看到它们，我们通过它们来展示电影的相关细节。回到ViewController.swift文件，根据下面的代码片段更新表视图的函数： func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCellWithIdentifier(&quot;idCellMovieSummary&quot;, forIndexPath: indexPath) as! MovieSummaryCell let currentMovieInfo = moviesInfo[indexPath.row] as! [String: String] cell.lblTitle.text = currentMovieInfo[&quot;Title&quot;]! cell.lblDescription.text = currentMovieInfo[&quot;Description&quot;]! cell.lblRating.text = currentMovieInfo[&quot;Rating&quot;]! cell.imgMovieImage.image = UIImage(named: currentMovieInfo[&quot;Image&quot;]!) return cell} 虽然currentMovieInfo这个字典不是必需的，但是它让上面的简单代码编写的更加容易。 这时你可以运行一次你的应用程序，并且可以看到电影的细节被展示在表视图。到目前为止，我们所做的这些是大家所熟知的,所以直接到第二个步骤:显示所选电影的细节。 数据细节展示 在MovieDetailsViewController这个类中，我们将要展示在ViewController类中tableView上选中的电影的细节。所有的界面构建已经完成,现在我们必须做两件事：把包含电影信息的字典从ViewController类传到MovieDetailsViewController类中，然后从字典取值赋值给这个类中相应的UI控件，这些控件的IBOutlet属性都已经被声明并且已经正确的连接到单个UI组件上。 所以，说到字典，让我们在MovieDetailsViewController类中做下面的声明： var movieInfo: [String: String]! 回到ViewController.swift文件，让我们看一下点击表视图的行时需要做的工作有哪些。当点击列表的一行时，我们需要知道点击行的索引，以便于从moviesInfo数组选择合适的字典，然后在视图跳转的时候把字典传递到下一个视图控制器。从tableview的委托方法中获取行索引是很容易的，但是我们需要一个自定义的属性来存储它，因此在ViewController类的顶部我们需要这么声明: var selectedMovieIndex: Int! 然后，我们需要用下面的方式处理tableView中选中row的索引: func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { selectedMovieIndex = indexPath.row performSegueWithIdentifier(&quot;idSegueShowMovieDetails&quot;, sender: self)} 有两个简单的事情需要处理：第一是把点击的行的索引存储在我们自定义的selectedMovieIndex属性中,然后执行跳转到展示电影详情的界面。然而，这是不够的，因为我们还未从moviesInfo数组中选择相应的包含电影信息的字典，并把它传递到MovieDetailsViewController这个类中。我们该怎么做呢？重写prepareForSegue:sender:函数，并实现我刚刚描述的功能。下面是代码，请看： override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { if let identifier = segue.identifier { if identifier == &quot;idSegueShowMovieDetails&quot; { let movieDetailsViewController = segue.destinationViewController as! MovieDetailsViewController movieDetailsViewController.movieInfo = moviesInfo[selectedMovieIndex] as! [String : String] } }} 很简单，我们只通过destinationViewController的segue属性获得MovieDetailsViewController实例，然后我们将包含电影信息的字典值赋给我们这部分开始时声明的movieInfo属性。 现在，再次打开MovieDetailsViewController.swift文件，我们将会在这里定义一个自定义的函数。在它里面，我们将会从movieInfo字典中取值赋给那些相应的控件，那么这部分的工作到这里就就结束了。下面的代码是一个简单的实现，所以不再做进一步的探讨： func populateMovieInfo() { lblTitle.text = movieInfo[&quot;Title&quot;]! lblCategory.text = movieInfo[&quot;Category&quot;]! lblDescription.text = movieInfo[&quot;Description&quot;]! lblDirector.text = movieInfo[&quot;Director&quot;]! lblStars.text = movieInfo[&quot;Stars&quot;]! lblRating.text = movieInfo[&quot;Rating&quot;]! imgMovieImage.image = UIImage(named: movieInfo[&quot;Image&quot;]!)} 最后，在viewWillAppear：中函数调用上面的函数，代码如下 override func viewWillAppear(animated: Bool) { … if movieInfo != nil { populateMovieInfo() }} 这一部分已经结束。再运行一下你的应用程序，一旦你选中tableView中的某一个电影机就会看到电影的详细介绍。 为Spotlight添加app的索引数据 通过使用iOS9中提供的Core Spotlight 框架，使得任何一款应用都可以通过Spotlight功能被搜索到。在Spotlight上通过用户的搜索行为找到app的关键在于使用Core Spotlight API索引到我们应用的数据。但是既不是我们的app也是不是CS API接口决定应该设置什么类型的数据。所以我们需要提供特定的数据格式给 API接口。 再具体点来说，就是我们想通过Spotlight功能搜索到得数据必须封装成CSSearchableItem类型的对象，然后一起组装到数组中并把这个数组传递给CS API 中供它索引。单个的CSSearchableItem对象包含一系列的属性，这些属性使得iOS系统可搜索对象的细节更加清楚。像在搜索时应该展示哪些数据片段（例如：电影名称、图片和影视简介等），哪些app的数据关键字需要在Spotlight上展示。CSSearchableItemAttributeSet 类对象为 CSSearchableItem对象提了许多属性，只需为我们所需要的属性赋值就好了。查看 官方文档 ，你可以找到所有支持的属性。 最后一步通常要做的是为Spotlight功能添加索引数据。一般情况下，实现流程如下步骤所示（包含添加索引）： 1、给每一条数据设置属性，例如电影模型数据(设置CSSearchableItemAttributeSet对象)。 2、使用上一步的属性值(CSSearchableItem对象)，为每一条数据初始化搜索项并赋值。 3、收集所有的可搜索项放到一个数组中。 4、使用上个步骤的数组作为Spotlight的索引数据。 我们将按照上面的步骤一个一个的实现，为了达到目标，我们将会在ViewController.swift这个文件内创建一个叫做setupSearchableContent（）的函数。在这部分功能实现结束之际，你会发现实现让你的数据可以被搜索到的功能一点也不难。不过，我不会一次性给你所有的实现代码；相反，为了你更容易理解，我打算把代码分为片段。别担心，代码量并不是那么多。 在我们开始实现新功能之前,我们必须先导入两个框架: import CoreSpotlightimport MobileCoreServices 我们定义一个新的方法，同时在方法中声明一个用来存放我们搜集到的搜索项的数组： func setupSearchableContent() { var searchableItems = CSSearchableItem} 现在在一个for循环中访问每一个包含电影信息的字典： func setupSearchableContent() { var searchableItems = CSSearchableItem for i in 0…(moviesInfo.count - 1) { let movie = moviesInfo[i] as! [String: String] }} 我们将为每一部电影创建一个CSSearchableItemAttributeSet对象，然后我们将为搜索项数据设置属性，这些搜索项数据将会在用户使用Spotlight搜索时作为搜索结果展示出来。在demo App中，我们将把电影的标题、简介和图片作为数据展示给用户。 func setupSearchableContent() { var searchableItems = CSSearchableItem for i in 0…(moviesInfo.count - 1) { let movie = moviesInfo[i] as! [String: String] let searchableItemAttributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeText as String) // Set the title. searchableItemAttributeSet.title = movie[&quot;Title&quot;]! // Set the movie image. let imagePathParts = movie[&quot;Image&quot;]!.componentsSeparatedByString(&quot;.&quot;) searchableItemAttributeSet.thumbnailURL = NSBundle.mainBundle().URLForResource(imagePathParts[0], withExtension: imagePathParts[1]) // Set the description. searchableItemAttributeSet.contentDescription = movie[&quot;Description&quot;]! }} 注意上面的片段代码中我们是如何设置电影数据模型中图片属性的。有两种实现方法：一种是为imge制定一个URL链接，另一种是为image提供一个NSData对象。最简单的方法是为每一个电影图片文件提供一个URL,因为我们知道它们就在程序应用包里面。然而，这样做就需要我们把每个图片文件名分割成实际名称和扩展类型，因此我们用String类的 componentsSeparatedByString:方法将这两个值分开。剩下的代码就容易理解了。 现在是时候为app在Spotlight上设置我们想要的data的关键字了。指定关键字之前要认真考虑，因为你的决定对用户和App在Spotlight上的曝光率起着最终的决定性作用。在demo App中我们把电影所属的类别和演员设置成关键字。 func setupSearchableContent() { var searchableItems = CSSearchableItem for i in 0…(moviesInfo.count - 1) { … var keywords = String let movieCategories = movie[&quot;Category&quot;]!.componentsSeparatedByString(&quot;, &quot;) for movieCategory in movieCategories { keywords.append(movieCategory) } let stars = movie[&quot;Stars&quot;]!.componentsSeparatedByString(&quot;, &quot;) for star in stars { keywords.append(star) } searchableItemAttributeSet.keywords = keywords }} 记住，电影的所有类别属性在MoviesData.plist文件中是用一个字符串值来表示的，并且它们被逗号隔开。所以很有必要把这个字符串分割出各种电影的种类使他们成为各个单独的值，然后把他们存入movieCategories数组中以方便及时访问。然后用一个for循环在keywords数组中添加分类的关键字。对电影数据模型的明星属性使用相同的步骤，也就是说我们再次把包好所有明星名字的字符串分割成单独的值，然后把他们存入keywords数组中。 上面的片段代码中最后一句代码是很重要的，我们为每一个电影数据模型设置了关键字属性。忘记了这一点，当用Spotlight搜索时将不会出现任何关于我们app的结果。 我们已经为Spotlight设置了属性和关键字，那么现在是时候初始化搜索项，并且把它们添加到searchableItems数组中，代码如下： func setupSearchableContent() { var searchableItems = CSSearchableItem for i in 0…(moviesInfo.count - 1) { … let searchableItem = CSSearchableItem(uniqueIdentifier: &quot;com.appcoda.SpotIt.(i)&quot;, domainIdentifier: &quot;movies&quot;, attributeSet: searchableItemAttributeSet) searchableItems.append(searchableItem) }} 上述searchableItem对象的初始化接受了三个参数: uniqueIdentifier：这个参数唯一地标识Spotlight当前搜索项。你可以用你喜欢的方式构造这个唯一标示符，但是注意一个细节：在这个例子中，我们为当前电影添加了索引标示符，因为之后我们需要用它来匹配索引相对应得电影细节展示界面。一般而言，在唯一标识符的值里面添加详情页要展示的数据是个好主意。一会你将会更好的理解电影数据模型的索引值的用途。 domainIdentifier:使用这个参数对搜索项进行分组。 attributeSet：它就是我们刚刚设置属性时的属性设置对象。 在最后，把新的搜索项添加到searchableItems数组中。 还有最后一步需要做，用Core Spotlight的API去索引这些搜索项。它发生在for循环之外地方: func setupSearchableContent() { … CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(searchableItems) { (error) -&gt; Void in if error != nil { print(error?.localizedDescription) } }} 上面的函数已经完成，但是我们需要调用它。我们将会在viewDidLoad（）函数中调用它： override func viewDidLoad() { … setupSearchableContent()} 现在我们准备第一次开始用Spotlight搜索电影。运行app，然后退出app使用Spotlight搜索上面我们设置的关键字。结果将会展现到你眼前,通过点击搜索结果中的任意项，这个app将自动启动。 实现目标 当用Spotlight搜索时，能够从应用程序中搜索到电影数据是会给人深刻的印象，但是我们还可以比这做的更好。现在，当选择一个搜索结果时，就会启动应用程序，并且展示出ViewController这个界面，但是我们目标是直接进到展示电影细节界面并可以直接看到所选择电影的信息。 尽管这听起来比较困难，或者难以实现，但是最终你会发现它很简单。在这个指定的demo app中，根据我们现有的数据展示所选电影项的详细信息会更简单。 这里主要的工作是重写UIKit中的一个名字叫做restoreUserActivityState：的函数，并处理Spotlight上选中的结果项。我们最终的目标是从搜索项的标识符（如果你还记得话，我们在上一个部分动态的创建了标识符）中提取出在moviesInfoarray数组中的电影模型的索引值，然后用它传递一个正确的电影数据字典并展示MovieDetailsViewController视图。 restoreUserActivityState：函数的参数是NSUserActivity对象。这个对象有一个字典类型的属性名为userInfo,这个字典包含Spotlight上选中搜索项的标识符。从这个标识符中我们可以提取出moviesInfo数组中电影数据模型的索引值，然后我们就可以展示电影详情页面的视图了。就这么多，下面看一下代码实现： override func restoreUserActivityState(activity: NSUserActivity) { if activity.activityType == CSSearchableItemActionType { if let userInfo = activity.userInfo { let selectedMovie = userInfo[CSSearchableItemActivityIdentifier] as! String selectedMovieIndex = Int(selectedMovie.componentsSeparatedByString(&quot;.&quot;).last!) performSegueWithIdentifier(&quot;idSegueShowMovieDetails&quot;, sender: self) } }} 如你所见，有必要先检查activity type是否和CSSearchableItemActionType匹配。老实说，在示例程序中这个并不重要，但是如果你在你的应用程序中处理多个NSUserActivity对象的情况下，有些事是不应该忘记的做的（例如，Handoff feature是ios8首次提出来的，并且它充分使用了NSUserActivityclass类）。在useInfo字典中identifer对象是一个字符串。一旦我们得到它，我们将基于点符号截取这个字符串，我们从截取的字符串数组中取出最后一个对象就是选中的电影数据模型在电影数据模型数组中的索引值。剩下的就工作就比较简单：将这个索引值复制给selectedMovieIndex属性，然后执行跳转。我们之前的实现将会完成剩余的工作。 现在切换到AppDelegate.swift文件。我们需要实现一个现在还未实现的代理函数。每次点击在Spotlight上搜索的一个结果时，那个函数就会调用一次，我们现在的任务是调用我们上面已经实现的函数，传递userActivity对象，请看下面的实现代码： func application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -&gt; Void) -&gt; Bool { let viewController = (window?.rootViewController as! UINavigationController).viewControllers[0] as! ViewController viewController.restoreUserActivityState(userActivity) return true} 在上面的代码片段中，我们要做的第一件事就是通过window属性访问ViewController视图控制器，以恢复到之前的用户活动状态。或者，不用上面的方法，你可以用NSNotificationCenter类发送一个自定义的通知，然后在ViewController 类中处理这个通知，但上面的方法更直接。 就这么多！我们的示例应用已经完成了，所以再次运行它，看看你在使用Spotlight搜索电影时会发生什么。 总结 iOS 9 中新的搜索API对开发者来说看起来相当的吸引人，它们使得用户更容易发现和访问APP。在这个教程中我们实现了所有Spotlight搜索App数据的相关操作，包括方便用户在Spotlight上搜索时App数据索引，以及如何把选中的结果项通过app处理后的数据展示给用户。在你的应用程序实现这样的功能肯定会提升用户体验,所以你应该在你当前和未来的项目认真考虑使用它。又到了结束的时候,我真希望你能发现这篇文章的有用之处! 作为参考，你 从GitHub上可以下载完整的工 程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己动手实现KVO]]></title>
      <url>%2F2017-05-18-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0KVO.html</url>
      <content type="text"><![CDATA[本篇会探究 KVO (Key-Value Observing) 实现机制，并去实践一番 - 利用 Runtime 自己动手去实现 KVO 。 KVO (Key-Value Observing) KVO 是 Objective-C 对观察者模式（Observer Pattern）的实现。也是 Cocoa Binding 的基础。当被观察对象的某个属性发生更改时，观察者对象会获得通知。 有意思的是，你不需要给被观察的对象添加任何额外代码，就能使用 KVO 。这是怎么做到的？ KVO 实现机制 KVO 的实现也依赖于 Objective-C 强大的 Runtime 。Apple 的文档有简单提到过 KVO 的实现： Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class … Apple 的文档真是一笔带过，唯一有用的信息也就是：被观察对象的 isa 指针会指向一个中间类，而不是原来真正的类。看来，Apple 并不希望过多暴露 KVO 的实现细节。不过，要是你用 runtime 提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露。Mike Ash 早在 2009 年就做了这么个探究。 简单概述下 KVO 的实现： 当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。自然，重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。 原来，这个中间类，继承自原本的那个类。不仅如此，Apple 还重写了 -class 方法，企图欺骗我们这个类没有变，就是原本那个类。更具体的信息，去跑一下 Mike Ash 的那篇文章里的代码就能明白，这里就不再重复。 KVO 缺陷 KVO 很强大，没错。知道它内部实现，或许能帮助更好地使用它，或在它出错时更方便调试。但官方实现的 KVO 提供的 API 实在不怎么样。 比如，你只能通过重写 -observeValueForKeyPath:ofObject:change:context: 方法来获得通知。想要提供自定义的 selector ，不行；想要传一个 block ，门都没有。而且你还要处理父类的情况 - 父类同样监听同一个对象的同一个属性。但有时候，你不知道父类是不是对这个消息有兴趣。虽然 context 这个参数就是干这个的，也可以解决这个问题 - 在 -addObserver:forKeyPath:options:context: 传进去一个父类不知道的 context。但总觉得框在这个 API 的设计下，代码写的很别扭。至少至少，也应该支持 block 吧。 有不少人都觉得官方 KVO 不好使的。Mike Ash 的 Key-Value Observing Done Right，以及获得不少分享讨论的 KVO Considered Harmful 都把 KVO 拿出来吊打了一番。所以在实际开发中 KVO 使用的情景并不多，更多时候还是用 Delegate 或 NotificationCenter。 自己实现 KVO 如果没找到理想的，就自己动手做一个。既然我们对官方的 API 不太满意，又知道如何去实现一个 KVO，那就尝试自己动手写一个简易的 KVO 玩玩。 首先，我们创建 NSObject 的 Category，并在头文件中添加两个 API： typedef void(^PGObservingBlock)(id observedObject, NSString *observedKey, id oldValue, id newValue); @interface NSObject (KVO) - (void)PG_addObserver:(NSObject *)observer forKey:(NSString *)key withBlock:(PGObservingBlock)block; - (void)PG_removeObserver:(NSObject *)observer forKey:(NSString *)key; @end 接下来，实现 PG_addObserver:forKey:withBlock: 方法。逻辑并不复杂： 检查对象的类有没有相应的 setter 方法。如果没有抛出异常； 检查对象 isa 指向的类是不是一个 KVO 类。如果不是，新建一个继承原来类的子类，并把 isa 指向这个新建的子类； 检查对象的 KVO 类重写过没有这个 setter 方法。如果没有，添加重写的 setter 方法； 添加这个观察者 - (void)PG_addObserver:(NSObject *)observer forKey:(NSString *)key withBlock:(PGObservingBlock)block { // Step 1: Throw exception if its class or superclasses doesn't implement the setter SEL setterSelector = NSSelectorFromString(setterForGetter(key)); Method setterMethod = class_getInstanceMethod([self class], setterSelector); if (!setterMethod) { // throw invalid argument exception } Class clazz = object_getClass(self); NSString *clazzName = NSStringFromClass(clazz); // Step 2: Make KVO class if this is first time adding observer and // its class is not an KVO class yet if (![clazzName hasPrefix:kPGKVOClassPrefix]) { clazz = [self makeKvoClassWithOriginalClassName:clazzName]; object_setClass(self, clazz); } // Step 3: Add our kvo setter method if its class (not superclasses) // hasn't implemented the setter if (![self hasSelector:setterSelector]) { const char *types = method_getTypeEncoding(setterMethod); class_addMethod(clazz, setterSelector, (IMP)kvo_setter, types); } // Step 4: Add this observation info to saved observation objects PGObservationInfo *info = [[PGObservationInfo alloc] initWithObserver:observer Key:key block:block]; NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge const void *)(kPGKVOAssociatedObservers)); if (!observers) { observers = [NSMutableArray array]; objc_setAssociatedObject(self, (__bridge const void *)(kPGKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } [observers addObject:info]; } 再来一步一步细看。 第一步里，先通过 setterForGetter() 方法获得相应的 setter 的名字（SEL）。也就是把 key 的首字母大写，然后前面加上 set 后面加上 :，这样 key 就变成了 setKey:。然后再用 class_getInstanceMethod 去获得 setKey: 的实现（Method）。如果没有，自然要抛出异常。 第二步，我们先看类名有没有我们定义的前缀。如果没有，我们就去创建新的子类，并通过 object_setClass() 修改 isa 指针。 - (Class)makeKvoClassWithOriginalClassName:(NSString *)originalClazzName { NSString *kvoClazzName = [kPGKVOClassPrefix stringByAppendingString:originalClazzName]; Class clazz = NSClassFromString(kvoClazzName); if (clazz) { return clazz; } // class doesn't exist yet, make it Class originalClazz = object_getClass(self); Class kvoClazz = objc_allocateClassPair(originalClazz, kvoClazzName.UTF8String, 0); // grab class method's signature so we can borrow it Method clazzMethod = class_getInstanceMethod(originalClazz, @selector(class)); const char *types = method_getTypeEncoding(clazzMethod); class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types); objc_registerClassPair(kvoClazz); return kvoClazz; } 动态创建新的类需要用 objc/runtime.h 中定义的 objc_allocateClassPair() 函数。传一个父类，类名，然后额外的空间（通常为 0），它返回给你一个类。然后就给这个类添加方法，也可以添加变量。这里，我们只重写了 class 方法。哈哈，跟 Apple 一样，这时候我们也企图隐藏这个子类的存在。最后 objc_registerClassPair() 告诉 Runtime 这个类的存在。 第三步，重写 setter 方法。新的 setter 在调用原 setter 方法后，通知每个观察者（调用之前传入的 block ）： static void kvo_setter(id self, SEL _cmd, id newValue) { NSString *setterName = NSStringFromSelector(_cmd); NSString *getterName = getterForSetter(setterName); if (!getterName) { // throw invalid argument exception } id oldValue = [self valueForKey:getterName]; struct objc_super superclazz = { .receiver = self, .super_class = class_getSuperclass(object_getClass(self)) }; // cast our pointer so the compiler won't complain void (*objc_msgSendSuperCasted)(void *, SEL, id) = (void *)objc_msgSendSuper; // call super's setter, which is original class's setter method objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue); // look up observers and call the blocks NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge const void *)(kPGKVOAssociatedObservers)); for (PGObservationInfo *each in observers) { if ([each.key isEqualToString:getterName]) { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ each.block(self, getterName, oldValue, newValue); }); } } } 细心的同学会发现我们对 objc_msgSendSuper 进行类型转换。在 Xcode 6 里，新的 LLVM 会对 objc_msgSendSuper 以及 objc_msgSend 做严格的类型检查，如果不做类型转换。Xcode 会抱怨有 too many arguments 的错误。（在 WWDC 2014 的视频 What new in LLVM 中有提到过这个问题。） 最后一步，把这个观察的相关信息存在 associatedObject 里。观察的相关信息（观察者，被观察的 key, 和传入的 block ）封装在 PGObservationInfo 类里。 @interface PGObservationInfo : NSObject @property (nonatomic, weak) NSObject *observer; @property (nonatomic, copy) NSString *key; @property (nonatomic, copy) PGObservingBlock block; @end 就此，一个基本的 KVO 就可以 work 了。当然，这只是一个一天多做出来的小东西，会有 bug，也有很多可以优化完善的地方。但作为 demo 演示如何利用 Runtime 动态创建类、如何实现 KVO，足已。 完整的例子可以从这里下载：ImplementKVO]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS线程安全篇]]></title>
      <url>%2F2017-05-17-iOS%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%AF%87.html</url>
      <content type="text"><![CDATA[一、前言前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有@synchronized、NSLock、dispatch_semaphore、NSCondition、pthread_mutex、OSSpinLock。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。不好意思，我们平常使用最多的@synchronized是性能最差的。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。二、介绍与使用2.1、@synchronizedNSObject&nbsp;obj&nbsp;=&nbsp;[[NSObject&nbsp;alloc]&nbsp;init];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;@synchronized(obj)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;开始”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;结束”);&nbsp;&nbsp;&nbsp;&nbsp;}});dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;sleep(1);&nbsp;&nbsp;&nbsp;&nbsp;@synchronized(obj)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作2”);&nbsp;&nbsp;&nbsp;&nbsp;}});@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。上面结果的执行结果为：2016-06-29&nbsp;20:48:35.747&nbsp;SafeMultiThread[35945:580107]&nbsp;需要线程同步的操作1&nbsp;开始2016-06-29&nbsp;20:48:38.748&nbsp;SafeMultiThread[35945:580107]&nbsp;需要线程同步的操作1&nbsp;结束2016-06-29&nbsp;20:48:38.749&nbsp;SafeMultiThread[35945:580118]&nbsp;需要线程同步的操作22.2、dispatch_semaphoredispatch_semaphore_t&nbsp;signal&nbsp;=&nbsp;dispatch_semaphore_create(1);dispatch_time_t&nbsp;overTime&nbsp;=&nbsp;dispatch_time(DISPATCH_TIME_NOW,&nbsp;3&nbsp;&nbsp;NSEC_PER_SEC);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_wait(signal,&nbsp;overTime);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;开始”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;结束”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_signal(signal);});dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_wait(signal,&nbsp;overTime);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作2”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dispatch_semaphore_signal(signal);});dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。（1）dispatch_semaphore_create的声明为：dispatch_semaphore_t&nbsp;dispatch_semaphore_create(long&nbsp;value);传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。（2）dispatch_semaphore_signal的声明为：long&nbsp;dispatch_semaphore_signal(dispatch_semaphore_t&nbsp;dsema);这个函数会使传入的信号量dsema的值加1；(3) dispatch_semaphore_wait的声明为：long&nbsp;dispatch_semaphore_wait(dispatch_semaphore_t&nbsp;dsema,&nbsp;dispatch_time_t&nbsp;timeout);这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。如上的代码，如果超时时间overTime设置成&gt;2，可完成同步操作。如果overTime上面代码的执行结果为：2016-06-29&nbsp;20:47:52.324&nbsp;SafeMultiThread[35945:579032]&nbsp;需要线程同步的操作1&nbsp;开始2016-06-29&nbsp;20:47:55.325&nbsp;SafeMultiThread[35945:579032]&nbsp;需要线程同步的操作1&nbsp;结束2016-06-29&nbsp;20:47:55.326&nbsp;SafeMultiThread[35945:579033]&nbsp;需要线程同步的操作2如果把超时时间设置为2016-06-30&nbsp;18:53:24.049&nbsp;SafeMultiThread[30834:434334]&nbsp;需要线程同步的操作1&nbsp;开始2016-06-30&nbsp;18:53:25.554&nbsp;SafeMultiThread[30834:434332]&nbsp;需要线程同步的操作22016-06-30&nbsp;18:53:26.054&nbsp;SafeMultiThread[30834:434334]&nbsp;需要线程同步的操作1&nbsp;结束2.3、NSLockNSLock&nbsp;lock&nbsp;=&nbsp;[[NSLock&nbsp;alloc]&nbsp;init];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;//[lock&nbsp;lock];&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;lockBeforeDate:[NSDate&nbsp;date]];&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;开始”);&nbsp;&nbsp;&nbsp;&nbsp;sleep(2);&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”需要线程同步的操作1&nbsp;结束”);&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;unlock];});dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;sleep(1);&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;([lock&nbsp;tryLock])&nbsp;{//尝试获取锁，如果获取不到返回NO，不会阻塞该线程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”锁可用的操作”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;unlock];&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”锁不可用的操作”);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;NSDate&nbsp;date&nbsp;=&nbsp;[[NSDate&nbsp;alloc]&nbsp;initWithTimeIntervalSinceNow:3];&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;([lock&nbsp;lockBeforeDate:date])&nbsp;{//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程,&nbsp;返回NO,不会阻塞该线程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”没有超时，获得锁”);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;unlock];&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”超时，没有获得锁”);&nbsp;&nbsp;&nbsp;&nbsp;}});NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。上面代码的执行结果为：2016-06-29&nbsp;20:45:08.864&nbsp;SafeMultiThread[35911:575795]&nbsp;需要线程同步的操作1&nbsp;开始2016-06-29&nbsp;20:45:09.869&nbsp;SafeMultiThread[35911:575781]&nbsp;锁不可用的操作2016-06-29&nbsp;20:45:10.869&nbsp;SafeMultiThread[35911:575795]&nbsp;需要线程同步的操作1&nbsp;结束2016-06-29&nbsp;20:45:10.870&nbsp;SafeMultiThread[35911:575781]&nbsp;没有超时，获得锁源码定义如下：@protocol&nbsp;NSLocking-&nbsp;(void)lock;-&nbsp;(void)unlock;@end@interface&nbsp;NSLock&nbsp;:&nbsp;NSObject&nbsp;&nbsp;{@private&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;_priv;}-&nbsp;(BOOL)tryLock;-&nbsp;(BOOL)lockBeforeDate:(NSDate&nbsp;)limit;@property&nbsp;(nullable,&nbsp;copy)&nbsp;NSString&nbsp;name&nbsp;NS_AVAILABLE(10_5,&nbsp;2_0);@end2.4、NSRecursiveLock递归锁//NSLock&nbsp;lock&nbsp;=&nbsp;[[NSLock&nbsp;alloc]&nbsp;init];NSRecursiveLock&nbsp;*lock&nbsp;=&nbsp;[[NSRecursiveLock&nbsp;alloc]&nbsp;init];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,&nbsp;0),&nbsp;^{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;(^RecursiveMethod)(int);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RecursiveMethod&nbsp;=&nbsp;^(int&nbsp;value)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;lock];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(value&nbsp;&gt;&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NSLog(@”value&nbsp;=&nbsp;%d”,&nbsp;value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sleep(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RecursiveMethod(value&nbsp;-&nbsp;1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[lock&nbsp;unlock];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RecursiveMethod(5);});]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C Runtime 1小时入门教程]]></title>
      <url>%2F2017-05-15-Objective-C-Runtime-1%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html</url>
      <content type="text"><![CDATA[一、前言： 如果你没有Objective-C基础，请学习了基础的iOS开发再来，这个1小时是给有一定iOS基础的童鞋的。如果你是大牛或者你感觉Objective-C Runtime太简单不用1小时学习的，也请您绕道，这或许只是我的私人笔记了。请跟着教程“一步步来”，请不要大概地扫两眼就说看不懂——以这种态度写成什么样你也看不懂。这是1小时入门教程，请不要试图在1分钟内入门！二、本文目标：1小时让你知道什么是Objective-C Runtime，并对它有一定的基本了解，可以在开发过程中运用自如。三、Objective-C Runtime到底是什么东西？简而言之，Objective-C Runtime是一个将C语言转化为面向对象语言的扩展。我们将C++和Objective进行对比，虽然C++和Objective-C都是在C的基础上加入面向对象的特性扩充而成的程序设计语言，但二者实现的机制差异很大。C++是基于静态类型，而Objective-C是基于动态运行时类型。也就是说用C++编写的程序编译时就直接编译成了可令机器读懂的机器语言；用Objective-C编写的程序不能直接编译成可令机器读懂的机器语言，而是在程序运行的时候，通过Runtime把程序转为可令机器读懂的机器语言。也就是说用C++编写的程序通过编译器直接把函数地址硬编码进入可执行文件；而Objective-C无法通过编译器直接把函数地址硬编码进入可执行文件，而是在程序运行的时候，利用Runtime根据条件判断作出决定。函数标识与函数过程的真正内容之间的关联可以动态修改。Runtime是Objective不可缺少的重要一部分。传送门-&gt;runtime源码四、Objective-C的元素认知4.1 id和Class打开/Public Headers/objc.h文件可以看到如下定义：#if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class.typedef struct objc_class Class;/// Represents an instance of a class.struct objc_object {Class isa OBJC_ISA_AVAILABILITY;};/// A pointer to an instance of a class.typedef struct objc_object id;#endifClass是一个指向objc_class结构体的指针，而id是一个指向objc_object结构体的指针，其中的isa是一个指向objc_class结构体的指针。其中的id就是我们所说的对象，Class就是我们所说的类。打开/Public Headers/runtime.h文件objc_class的定义如下：typedef struct objc_class Class;struct objc_class {Class isa OBJC_ISA_AVAILABILITY; // metaclass#if !OBJC2Class super_class OBJC2_UNAVAILABLE; // 父类const char name OBJC2_UNAVAILABLE; // 类名long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取long info OBJC2_UNAVAILABLE; // 类信息，供运行时期使用的一些位标识，如CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小（包括从父类继承下来的实例变量）struct objc_ivar_list ivars OBJC2_UNAVAILABLE; // 该类的成员变量地址列表struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法地址列表，与 info 的一些标志位有关，如CLS_CLASS (0x1L)，则存储实例方法，如CLS_META (0x2L)，则存储类方法;struct objc_cache cache OBJC2_UNAVAILABLE; // 缓存最近使用的方法地址，用于提升效率；struct objc_protocol_list protocols OBJC2_UNAVAILABLE; // 存储该类声明遵守的协议的列表#endif}/ Use Class instead of struct objc_class * /由以上代码可见，类与对象的区别就是类比对象多了很多特征成员，类也可以当做一个objc_object来对待，也就是说类和对象都是对象，分别称作类对象（class object）和实例对象（instance object），这样我们就可以区别对象和类了。isa：objc_object（实例对象）中isa指针指向的类结构称为class（也就是该对象所属的类）其中存放着普通成员变量与动态方法（“-”开头的方法）；此处isa指针指向的类结构称为metaclass，其中存放着static类型的成员变量与static类型的方法（“+”开头的方法）。super_class： 指向该类的父类的指针，如果该类是根类（如NSObject或NSProxy），那么super_class就为nil。类与对象的继承层次关系如图（图片源自网络）：所有的metaclass中isa指针都是指向根metaclass，而根metaclass则指向自身。根metaclass是通过继承根类产生的，与根class结构体成员一致，不同的是根metaclass的isa指针指向自身。4.2 SELSEL是selector在Objective-C中的表示类型。selector可以理解为区别方法的ID。typedef struct objc_selector SEL;objc_selector的定义如下：struct objc_selector {char name; OBJC2_UNAVAILABLE;// 名称char types; OBJC2_UNAVAILABLE;// 类型};name和types都是char类型。4.3 IMP终于到IMP了，它在objc.h中得定义如下：typedef id (IMP)(id, SEL, …);IMP是“implementation”的缩写，它是由编译器生成的一个函数指针。当你发起一个消息后（下文介绍），这个函数指针决定了最终执行哪段代码。4.4 MethodMethod代表类中的某个方法的类型。typedef struct objc_method Method;objc_method的定义如下：struct objc_method {SEL method_name OBJC2_UNAVAILABLE; // 方法名char method_types OBJC2_UNAVAILABLE; // 方法类型IMP method_imp OBJC2_UNAVAILABLE; // 方法实现}方法名method_name类型为SEL，上文提到过。方法类型method_types是一个char指针，存储着方法的参数类型和返回值类型。方法实现method_imp的类型为IMP，上文提到过。4.5 IvarIvar代表类中实例变量的类型typedef struct objc_ivar Ivar;objc_ivar的定义如下：struct objc_ivar {char ivar_name OBJC2_UNAVAILABLE; // 变量名char ivar_type OBJC2_UNAVAILABLE; // 变量类型int ivar_offset OBJC2_UNAVAILABLE; // 基地址偏移字节#ifdef LP64int space OBJC2_UNAVAILABLE; // 占用空间#endif}4.6 objc_property_tobjc_property_t是属性，它的定义如下：typedef struct objc_property objc_property_t;objc_property是内置的类型，与之关联的还有一个objc_property_attribute_t，它是属性的attribute，也就是其实是对属性的详细描述，包括属性名称、属性编码类型、原子类型/非原子类型等。它的定义如下：typedef struct {const char name; // 名称const char value; // 值（通常是空的）} objc_property_attribute_t;4.7 CacheCatch的定义如下：typedef struct objc_cache Cacheobjc_cache的定义如下：struct objc_cache {unsigned int mask OBJC2_UNAVAILABLE;unsigned int occupied OBJC2_UNAVAILABLE;Method buckets[1] OBJC2_UNAVAILABLE;};mask: 指定分配cache buckets的总数。在方法查找中，Runtime使用这个字段确定数组的索引位置。occupied: 实际占用cache buckets的总数。buckets: 指定Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。objc_msgSend（下文讲解）每调用一次方法后，就会把该方法缓存到cache列表中，下次的时候，就直接优先从cache列表中寻找，如果cache没有，才从methodLists中查找方法。4.8 Catagory这个就是我们平时所说的类别了，很熟悉吧。它可以动态的为已存在的类添加新的方法。它的定义如下：typedef struct objc_category Category;objc_category的定义如下：struct objc_category {char category_name OBJC2_UNAVAILABLE; // 类别名称char class_name OBJC2_UNAVAILABLE; // 类名struct objc_method_list instance_methods OBJC2_UNAVAILABLE; // 实例方法列表struct objc_method_list class_methods OBJC2_UNAVAILABLE; // 类方法列表struct objc_protocol_list protocols OBJC2_UNAVAILABLE; // 协议列表}因为是入门，以上就列举这些吧！五、Objective-C的消息传递5.1 基本消息传递在面向对象编程中，对象调用方法叫做发送消息。在编译时，程序的源代码就会从对象发送消息转换成Runtime的objc_msgSend函数调用。例如某实例变量receiver实现某一个方法oneMethod[receiver oneMethod];Runtime会将其转成类似这样的代码objc_msgSend(receiver, selector);具体会转换成什么代码呢？Runtime会根据类型自动转换成下列某一个函数：objc_msgSend:普通的消息都会通过该函数发送objc_msgSend_stret:消息中有数据结构作为返回值（不是简单值）时，通过此函数发送和接收返回值objc_msgSendSuper:和objc_msgSend类似，这里把消息发送给父类的实例objc_msgSendSuper_stret:和objc_msgSend_stret类似，这里把消息发送给父类的实例并接收返回值当消息被发送到实例对象时，是如图所示处理的（图片源自网络）：objc_msgSend函数的调用过程：第一步：检测这个selector是不是要忽略的。第二步：检测这个target是不是nil对象。nil对象发送任何一个消息都会被忽略掉。第三步：1.调用实例方法时，它会首先在自身isa指针指向的类（class）methodLists中查找该方法，如果找不到则会通过class的super_class指针找到父类的类对象结构体，然后从methodLists中查找该方法，如果仍然找不到，则继续通过super_class向上一级父类结构体中查找，直至根class；2.当我们调用某个某个类方法时，它会首先通过自己的isa指针找到metaclass，并从其中methodLists中查找该类方法，如果找不到则会通过metaclass的super_class指针找到父类的metaclass对象结构体，然后从methodLists中查找该方法，如果仍然找不到，则继续通过super_class向上一级父类结构体中查找，直至根metaclass；第四部：前三部都找不到就会进入动态方法解析(看下文)。5.2 消息动态解析动态解析流程图（图片来自网络）：请参照图片品味以下步骤（实例请看下文《6.6 苍老师的唱歌篇》）：第一步：通过resolveInstanceMethod：方法决定是否动态添加方法。如果返回Yes则通过class_addMethod动态添加方法，消息得到处理，结束；如果返回No，则进入下一步；第二步：这步会进入forwardingTargetForSelector:方法，用于指定备选对象响应这个selector，不能指定为self。如果返回某个对象则会调用对象的方法，结束。如果返回nil，则进入第三部；第三部：这步我们要通过methodSignatureForSelector:方法签名，如果返回nil，则消息无法处理。如果返回methodSignature，则进入下一步；第四部：这步调用forwardInvocation：方法，我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果失败，则进入doesNotRecognizeSelector方法，若我们没有实现这个方法，那么就会crash。到这里大家可能晕乎乎的，下面看实战篇吧！苍老师必须让你懂！六、Runtime实战请大家放心，以下所有实战篇，在最后都会分享Demo给大家！6.1 苍老师问好篇苍老师见到我们广大的粉丝们，第一反应当然是：大家好！#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif// 自定义一个方法void sayFunction(id self, SEL _cmd, id some) {NSLog(@”%@岁的%@说：%@”, object_getIvar(self, class_getInstanceVariable([self class], “_age”)),[self valueForKey:@”name”],some);}int main(int argc, const char argv[]) {@autoreleasepool {// 动态创建对象 创建一个Person 继承自 NSObject类Class People = objc_allocateClassPair([NSObject class], “Person”, 0);// 为该类添加NSString _name成员变量class_addIvar(People, “_name”, sizeof(NSString), log2(sizeof(NSString)), @encode(NSString));// 为该类添加int _age成员变量class_addIvar(People, “_age”, sizeof(int), sizeof(int), @encode(int));// 注册方法名为say的方法SEL s = sel_registerName(“say:”);// 为该类增加名为say的方法class_addMethod(People, s, (IMP)sayFunction, “v@:@”);// 注册该类objc_registerClassPair(People);// 创建一个类的实例id peopleInstance = [[People alloc] init];// KVC 动态改变 对象peopleInstance 中的实例变量[peopleInstance setValue:@”苍老师” forKey:@”name”];// 从类中获取成员变量IvarIvar ageIvar = class_getInstanceVariable(People, “_age”);// 为peopleInstance的成员变量赋值object_setIvar(peopleInstance, ageIvar, @18);// 调用 peopleInstance 对象中的 s 方法选择器对于的方法// objc_msgSend(peopleInstance, s, @”大家好!”); // 这样写也可以，请看我博客说明((void ()(id, SEL, id))objc_msgSend)(peopleInstance, s, @”大家好”);peopleInstance = nil; //当People类或者它的子类的实例还存在，则不能调用objc_disposeClassPair这个方法；因此这里要先销毁实例对象后才能销毁类；// 销毁类objc_disposeClassPair(People);}return 0;}最后的结果是：18岁的苍老师说：大家好！在使用objc_msgSend(peopleInstance, s, @”大家好!”);默认会出现以下错误：objc_msgSend()报错Too many arguments to function call ,expected 0,have3直接通过objc_msgSend(self, setter, value)是报错，说参数过多。请这样解决：Build Setting&#8211;&gt; Apple LLVM 7.0 &#8211; Preprocessing&#8211;&gt; Enable Strict Checking of objc_msgSend Calls 改为 NO当然你也可以这样写(推荐)：((void ()(id, SEL, id))objc_msgSend)(peopleInstance, s, @”大家好”);强制转换objc_msgSend函数类型为带三个参数且返回值为void函数，然后才能传三个参数。此实战内容是，动态创建一个类，并创建成员变量和方法，最后赋值成员变量并发送消息。其中成员变量的赋值使用了KVC和object_setIvar函数两种方式，这些东西大家举一反三就可以了。Demo传送门-&gt;6.1苍老师问好篇Demo6.2 苍老师的特征篇苍老师在大家心目中应该有很多特征吧，下面我们通过代码来获取苍老师的特征。People.h文件@interface People : NSObject{NSString _occupation;NSString _nationality;}@property (nonatomic, copy) NSString name;@property (nonatomic) NSUInteger age;- (NSDictionary )allProperties;- (NSDictionary )allIvars;- (NSDictionary )allMethods;@endPeople.m文件#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People- (NSDictionary )allProperties{unsigned int count = 0;// 获取类的所有属性，如果没有属性count就为0objc_property_t properties = class_copyPropertyList([self class], &amp;count);NSMutableDictionary resultDict = [@{} mutableCopy];for (NSUInteger i = 0; i &lt; count; i ++) {// 获取属性的名称和值const char propertyName = property_getName(properties[i]);NSString name = [NSString stringWithUTF8String:propertyName];id propertyValue = [self valueForKey:name];if (propertyValue) {resultDict[name] = propertyValue;} else {resultDict[name] = @”字典的key对应的value不能为nil哦！”;}}// 这里properties是一个数组指针，我们需要使用free函数来释放内存。free(properties);return resultDict;}- (NSDictionary )allIvars{unsigned int count = 0;NSMutableDictionary resultDict = [@{} mutableCopy];Ivar ivars = class_copyIvarList([self class], &amp;count);for (NSUInteger i = 0; i &lt; count; i ++) {const char varName = ivar_getName(ivars[i]);NSString name = [NSString stringWithUTF8String:varName];id varValue = [self valueForKey:name];if (varValue) {resultDict[name] = varValue;} else {resultDict[name] = @”字典的key对应的value不能为nil哦！”;}}free(ivars);return resultDict;}- (NSDictionary )allMethods{unsigned int count = 0;NSMutableDictionary resultDict = [@{} mutableCopy];// 获取类的所有方法，如果没有方法count就为0Method methods = class_copyMethodList([self class], &amp;count);for (NSUInteger i = 0; i &lt; count; i ++) {// 获取方法名称SEL methodSEL = method_getName(methods[i]);const char methodName = sel_getName(methodSEL);NSString name = [NSString stringWithUTF8String:methodName];// 获取方法的参数列表int arguments = method_getNumberOfArguments(methods[i]);resultDict[name] = @(arguments-2);}free(methods);return resultDict;}@end在main.m中运行以下代码int main(int argc, const char argv[]) {@autoreleasepool {People cangTeacher = [[People alloc] init];cangTeacher.name = @”苍井空”;cangTeacher.age = 18;[cangTeacher setValue:@”老师” forKey:@”occupation”];NSDictionary propertyResultDic = [cangTeacher allProperties];for (NSString propertyName in propertyResultDic.allKeys) {NSLog(@”propertyName:%@, propertyValue:%@”,propertyName, propertyResultDic[propertyName]);}NSDictionary ivarResultDic = [cangTeacher allIvars];for (NSString ivarName in ivarResultDic.allKeys) {NSLog(@”ivarName:%@, ivarValue:%@”,ivarName, ivarResultDic[ivarName]);}NSDictionary methodResultDic = [cangTeacher allMethods];for (NSString methodName in methodResultDic.allKeys) {NSLog(@”methodName:%@, argumentsCount:%@”, methodName, methodResultDic[methodName]);}}return 0;}最后的输出结果如下：是不是有点失望，我没有加一些特殊的技能，留给下文了。此实战内容是通过苍老师的一些特征学习：如何获取对象所有的属性名称和属性值、获取对象所有成员变量名称和变量值、获取对象所有的方法名和方法参数数量。Demo传送门-&gt;6.2苍老师的特征篇Demo6.3 苍老师增加新技能篇苍老师要通过Category和Associated Objects增加技能了，快看！创建People+Associated.h文件如下：#import “People.h”typedef void (^CodingCallBack)();@interface People (Associated)@property (nonatomic, strong) NSNumber associatedBust; // 胸围@property (nonatomic, copy) CodingCallBack associatedCallBack; // 写代码@endPeople+Associated.m如下:#import “People+Associated.h”#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People (Associated)- (void)setAssociatedBust:(NSNumber )bust{// 设置关联对象objc_setAssociatedObject(self, @selector(associatedBust), bust, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (NSNumber )associatedBust{// 得到关联对象return objc_getAssociatedObject(self, @selector(associatedBust));}- (void)setAssociatedCallBack:(CodingCallBack)callback {objc_setAssociatedObject(self, @selector(associatedCallBack), callback, OBJC_ASSOCIATION_COPY_NONATOMIC);}- (CodingCallBack)associatedCallBack {return objc_getAssociatedObject(self, @selector(associatedCallBack));}@end在main.m中运行以下代码#import “People.h”#import “People+Associated.h”int main(int argc, const char argv[]) {@autoreleasepool {People cangTeacher = [[People alloc] init];cangTeacher.name = @”苍井空”;cangTeacher.age = 18;[cangTeacher setValue:@”老师” forKey:@”occupation”];cangTeacher.associatedBust = @(90);cangTeacher.associatedCallBack = ^(){NSLog(@”苍老师要写代码了！”);};cangTeacher.associatedCallBack();NSDictionary propertyResultDic = [cangTeacher allProperties];for (NSString propertyName in propertyResultDic.allKeys) {NSLog(@”propertyName:%@, propertyValue:%@”,propertyName, propertyResultDic[propertyName]);}NSDictionary methodResultDic = [cangTeacher allMethods];for (NSString methodName in methodResultDic.allKeys) {NSLog(@”methodName:%@, argumentsCount:%@”, methodName, methodResultDic[methodName]);}}return 0;}这次运行结果多出了一个associatedBust（胸围）和一个associatedCallBack（写代码）属性。如图：我们成功的给苍老师添加个一个胸围的属性和一个写代码的回调，但是添加属性没有什么意义，我们平时在开发过成功中用的比较多的就是添加回调了。Demo传送门-&gt;6.3苍老师增加新技能篇Demo6.4 苍老师的资料归档篇苍老师的资料总要整理一下吧！创建People.h#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject &lt;NSCoding&gt;@property (nonatomic, copy) NSString name; // 姓名@property (nonatomic, strong) NSNumber age; // 年龄@property (nonatomic, copy) NSString occupation; // 职业@property (nonatomic, copy) NSString nationality; // 国籍@endPeople.m#import “People.h”#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People- (void)encodeWithCoder:(NSCoder )aCoder {unsigned int count = 0;Ivar ivars = class_copyIvarList([People class], &amp;count);for (NSUInteger i = 0; i &lt; count; i ++) {Ivar ivar = ivars[i];const char name = ivar_getName(ivar);NSString key = [NSString stringWithUTF8String:name];id value = [self valueForKey:key];[aCoder encodeObject:value forKey:key];}free(ivars);}- (id)initWithCoder:(NSCoder )aDecoder {self = [super init];if (self) {unsigned int count = 0;Ivar ivars = class_copyIvarList([People class], &amp;count);for (NSUInteger i = 0; i &lt; count; i ++) {Ivar ivar = ivars[i];const char name = ivar_getName(ivar);NSString key = [NSString stringWithUTF8String:name];id value = [aDecoder decodeObjectForKey:key];[self setValue:value forKey:key];}free(ivars);}return self;}@endDemo传送门-&gt;6.4苍老师的资料归档篇Demo6.5 苍老师的资料转换篇服务器返回了大量苍老师的数据，手机端这边接收后如何去转换呢？当然是要将JSON转换为Model啦！相信平时你们的项目中也用到过这些三方库，下面我们去了解下runtime实现JSON和Model互转。创建People.h#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject@property (nonatomic, copy) NSString name; // 姓名@property (nonatomic, strong) NSNumber age; // 年龄@property (nonatomic, copy) NSString occupation; // 职业@property (nonatomic, copy) NSString nationality; // 国籍// 生成model- (instancetype)initWithDictionary:(NSDictionary )dictionary;// 转换成字典- (NSDictionary )covertToDictionary;@endPeople.m的代码如下：#import “People.h”#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People- (instancetype)initWithDictionary:(NSDictionary )dictionary{self = [super init];if (self) {for (NSString key in dictionary.allKeys) {id value = dictionary[key];SEL setter = [self propertySetterByKey:key];if (setter) {// 这里还可以使用NSInvocation或者method_invoke，不再继续深究了，有兴趣google。((void ()(id, SEL, id))objc_msgSend)(self, setter, value);}}}return self;}- (NSDictionary )covertToDictionary{unsigned int count = 0;objc_property_t properties = class_copyPropertyList([self class], &amp;count);if (count != 0) {NSMutableDictionary resultDict = [@{} mutableCopy];for (NSUInteger i = 0; i &lt; count; i ++) {const void propertyName = property_getName(properties[i]);NSString name = [NSString stringWithUTF8String:propertyName];SEL getter = [self propertyGetterByKey:name];if (getter) {id value = ((id ()(id, SEL))objc_msgSend)(self, getter);if (value) {resultDict[name] = value;} else {resultDict[name] = @”字典的key对应的value不能为nil哦！”;}}}free(properties);return resultDict;}free(properties);return nil;}#pragma mark - private methods// 生成setter方法- (SEL)propertySetterByKey:(NSString )key{// 首字母大写，你懂得NSString propertySetterName = [NSString stringWithFormat:@”set%@:”, key.capitalizedString];SEL setter = NSSelectorFromString(propertySetterName);if ([self respondsToSelector:setter]) {return setter;}return nil;}// 生成getter方法- (SEL)propertyGetterByKey:(NSString )key{SEL getter = NSSelectorFromString(key);if ([self respondsToSelector:getter]) {return getter;}return nil;}@endmain.m中运行以下代码：#import &lt;Foundation/Foundation.h&gt;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import “People.h”int main(int argc, const char argv[]) {@autoreleasepool {NSDictionary dict = @{@”name” : @”苍井空”,@”age” : @18,@”occupation” : @”老师”,@”nationality” : @”日本”};// 字典转模型People cangTeacher = [[People alloc] initWithDictionary:dict];NSLog(@”热烈欢迎，从%@远道而来的%@岁的%@%@”,cangTeacher.nationality,cangTeacher.age,cangTeacher.name,cangTeacher.occupation);// 模型转字典NSDictionary covertedDict = [cangTeacher covertToDictionary];NSLog(@”%@”,covertedDict);}return 0;}最后输出内容如下：相信通过前面的学习，这些代码不用写过多的注释你也可以看懂了，我把假设是网络返回的苍老师的资料转化为了model，然后又将model转回字典。这是一个JSON转Model相互转换的一个思路，大家稍后运行Demo细细品味。Demo传送门-&gt;6.5苍老师的资料转换篇Demo6.6 苍老师的唱歌篇这个实例主要是验证一下上文《5.2 消息动态解析》第一首：添加sing实例方法，但是不提供方法的实现。验证当找不到方法的实现时，动态添加方法。创建People.h#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject@property (nonatomic, copy) NSString name;- (void)sing;@end创建People.m#import “People.h”#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People+ (BOOL)resolveInstanceMethod:(SEL)sel{// 我们没有给People类声明sing方法，我们这里动态添加方法if ([NSStringFromSelector(sel) isEqualToString:@”sing”]) {class_addMethod(self, sel, (IMP)otherSing, “v@:”);return YES;}return [super resolveInstanceMethod:sel];}void otherSing(id self, SEL cmd){NSLog(@”%@ 唱歌啦！”,((People )self).name);}在main.m中运行以下代码：#import &lt;Foundation/Foundation.h&gt;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import “People.h”int main(int argc, const char argv[]) {@autoreleasepool {People cangTeacher = [[People alloc] init];cangTeacher.name = @”苍老师”;[cangTeacher sing];}return 0;}结果如下：我们没有提供苍老师唱歌的方法实现，因此在调用此方法的时候，会调用resolveInstanceMethod方法，我们动态添加了方法。我们也可以返回No，继续向下传递。（此处请返回《5.2 消息动态解析》第一步品味下）Demo传送门-&gt;6.6苍老师唱歌篇(第一首)Demo第二首外面的小鸟在唱歌，但是苍老师的歌声盖过了小鸟，我们只能听到苍老师唱歌了。这里我们不声明sing方法，将调用途中动态更换调用对象。在第一首代码的基础上，创建Bird的modelBird.h#import &lt;Foundation/Foundation.h&gt;@interface Bird : NSObject@property (nonatomic, copy) NSString name;@endBird.m#import “Bird.h”#import “People.h”@implementation Bird// 第一步：我们不动态添加方法，返回NO，进入第二步；+ (BOOL)resolveInstanceMethod:(SEL)sel{return NO;}// 第二部：我们不指定备选对象响应aSelector，进入第三步；- (id)forwardingTargetForSelector:(SEL)aSelector{return nil;}// 第三步：返回方法选择器，然后进入第四部；- (NSMethodSignature )methodSignatureForSelector:(SEL)aSelector{if ([NSStringFromSelector(aSelector) isEqualToString:@”sing”]) {return [NSMethodSignature signatureWithObjCTypes:”v@:”];}return [super methodSignatureForSelector:aSelector];}// 第四部：这步我们修改调用对象- (void)forwardInvocation:(NSInvocation )anInvocation{// 我们改变调用对象为PeoplePeople cangTeacher = [[People alloc] init];cangTeacher.name = @”苍老师”;[anInvocation invokeWithTarget:cangTeacher];}@endmain.m运行代码如下：#import &lt;Foundation/Foundation.h&gt;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import “People.h”#import “Bird.h”int main(int argc, const char argv[]) {@autoreleasepool {Bird bird = [[Bird alloc] init];bird.name = @”小小鸟”;((void ()(id, SEL))objc_msgSend)((id)bird, @selector(sing));}return 0;}运行结果如下：成功更换了对象，把对象更换为苍老师了。（此处请返回《5.2 消息动态解析》品味）Demo传送门-&gt;6.6苍老师唱歌篇(第二首)Demo第三首苍老师不想唱歌想跳舞了。这里我是实现不提供声明，不修改调用对象，但是将sing方法修改为dance方法。创建People.h#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject@endPeople.m#import “People.h”#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif@implementation People// 第一步：我们不动态添加方法，返回NO，进入第二步；+ (BOOL)resolveInstanceMethod:(SEL)sel{return NO;}// 第二部：我们不指定备选对象响应aSelector，进入第三步；- (id)forwardingTargetForSelector:(SEL)aSelector{return nil;}// 第三步：返回方法选择器，然后进入第四部；- (NSMethodSignature )methodSignatureForSelector:(SEL)aSelector{if ([NSStringFromSelector(aSelector) isEqualToString:@”sing”]) {return [NSMethodSignature signatureWithObjCTypes:”v@:”];}return [super methodSignatureForSelector:aSelector];}// 第四部：这步我们修改调用方法- (void)forwardInvocation:(NSInvocation )anInvocation{[anInvocation setSelector:@selector(dance)];// 这还要指定是哪个对象的方法[anInvocation invokeWithTarget:self];}// 若forwardInvocation没有实现，则会调用此方法- (void)doesNotRecognizeSelector:(SEL)aSelector{NSLog(@”消息无法处理：%@”, NSStringFromSelector(aSelector));}- (void)dance{NSLog(@”跳舞！！！come on！”);}@end在main.m中运行如下代码：#import &lt;Foundation/Foundation.h&gt;#if TARGET_IPHONE_SIMULATOR#import &lt;objc/objc-runtime.h&gt;#else#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;#endif#import “People.h”int main(int argc, const char argv[]) {@autoreleasepool {People cangTeacher = [[People alloc] init];((void(*)(id, SEL)) objc_msgSend)((id)cangTeacher, @selector(sing));}return 0;}结果如图：成功更换了方法，苍老师由唱歌改为跳舞了（此处请返回《5.2 消息动态解析》品味）Demo传送门-&gt;6.6苍老师唱歌篇(第三首)Demo总结好吧，我承认我骗了你，当你读到这里你肯定花了不止1小时。都是我的错，不是因为你笨，之所以说1小时是为了让你有信心，有耐心继续下去。读到这里恭喜你已经在iOS开发的道路上又向前了一步！同时我也要感谢以下参考文献以及文章，是他们让我更好的理解了runtime，再次表示感谢！这篇文章断断续续写了将近一周的时间，您可以读到这里就是对我最大的鼓励，谢谢！Demo传送门-&gt;所有的Demo打包下载 原文地址 本文参考文献以及文章：Objective-C Runtime ReferenceObject Model初识Objective-C RuntimeObjective-C RuntimeObjective-C Runtime 运行时之一：类与对象Runtime Message Forwardingruntime模型与字典互转iOS开发之深入探讨runtime机制Objective-C runtime之消息（二）Objective-C runtime之消息转发机制（三）《编写高质量代码：改善Objective-C程序的61个建议》《正则表达式30分钟入门教程》（参考写作方式）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift使用OC框架]]></title>
      <url>%2F2017-05-11-Swift%E4%BD%BF%E7%94%A8OC%E6%A1%86%E6%9E%B6.html</url>
      <content type="text"><![CDATA[Swift使用OC框架 场景一：使用Cocopods导入框架看以前的教程用Cocopods导入框架也要手动设置桥接文件，我最近创建的项目用Cocopods安装的SDWebImage和SVProgressHUD发现xcode会自动生成一个桥接的.h文件名字是Targets-Bridging-Header.h,并且会自动设置路径如图，这个稍后在场景2再继续介绍 用Cocopods导入的OC框架Xcode会自动生成一个文件但是我并不能在本地找到他，看SDWebImage的这个文件如下在使用的过程中直接用import SDWebImage就可以使用 SDWebImage的各种方法了这种由Cocopods导入的框架都会生成这个类似的文件不用在桥接文件有引入头文件类似#import “UIImageView+WebCache.h”. 场景二：没有使用Cocopods或者使用Cocopods手动导入框架没有使用Cocopods就需要自己新建一个桥接文件了当然如果用了Cocopods可以使用Xcode自动生成的就是场景一的那种情况了,下图新建一个桥接文件命名随意这里的图是用别人的真是随意了啊，我建议命名规则可以按照Targets-Bridging-Header.h毕竟这样看起来正规点嘛填好文件名字,选中语言为Objective-C,点击Next 这个时候回出现一个弹框,意思就是 你是否想要配置一个OC桥接文件,选择创建，路径可以按照场景一的图找到就不再上图了。这里强调一个重要设置注意、注意、注意重要的事情说三遍嘛1.选择target（就是左边你的工程target）—— BuildSettings —— search Paths 下的 User Header Search Paths 2.双击后面的空白区域，并且点击“+”号添加一项：并且输入：“$(PODS_ROOT)”（没有引号），选择：recursive（会在相应的目录递归搜索文件）。 这个设置完才可以保证在桥接文件里能够正常引用OC库 一切设置妥当就可以手动拖入OC库了，举个例子我用的Toast 愉快使用OC和Swift的混编吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC中load方法和initialize方法的区别]]></title>
      <url>%2F2017-05-10-OC%E4%B8%ADload%E6%96%B9%E6%B3%95%E5%92%8Cinitialize%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="text"><![CDATA[OC中有两个特殊的类方法，分别是load和initialize。本文总结一下这两个方法的区别于联系、使用场景和注意事项。Demo可以在我的Github上找到——load和initialize，如果觉得有帮助还望点个star以示支持，总结在文章末尾。load顾名思义，load方法在这个文件被程序装载时调用。只要是在Compile Sources中出现的文件总是会被装载，这与这个类是否被用到无关，因此load方法总是在main函数之前调用。调用规则如果一个类实现了load方法，在调用这个方法前会首先调用父类的load方法。而且这个过程是自动完成的，并不需要我们手动实现：// In Parent.m+ (void)load { NSLog(@”Load Class Parent”);}// In Child.m，继承自Parent+ (void)load { NSLog(@”Load Class Child”);}// In Child+load.m，Child类的分类+ (void)load { NSLog(@”Load Class Child+load”);}// 运行结果：/ 2016-02-01 21:28:14.379 load[11789:1435378] Load Class Parent 2016-02-01 21:28:14.380 load[11789:1435378] Load Class Child 2016-02-01 22:28:14.381 load[11789:1435378] Load Class Child+load /如果一个类没有实现load方法，那么就不会调用它父类的load方法，这一点与正常的类继承和方法调用不一样，需要额外注意一下。执行顺序load方法调用时，系统处于脆弱状态，如果调用别的类的方法，且该方法依赖于那个类的load方法进行初始化设置，那么必须确保那个类的load方法已经调用了，比如demo中的这段代码，打印出的字符串就为null： 12345678910// In Child.m+ (void)load &#123; NSLog(@&quot;Load Class Child&quot;); Other *other = [Other new]; [other originalFunc]; // 如果不先调用other的load，下面这行代码就无效，打印出null [Other printName];&#125; load方法的调用顺序其实有迹可循，我们看到demo的项目设置如下：执行顺序在Compile Sources中，文件的排放顺序就是其装载顺序，自然也就是load方法调用的顺序。这一点也证明了load方法中会自动调用父类的方法，因为在demo的输出结果中，Parent的load方法先于Child调用，而它的装载顺序其实在Child之后。虽然在这种简单情况下我们可以辨别出各个类的load方法调用的顺序，但永远不要依赖这个顺序完成你的代码逻辑。一方面，这在后期的开发中极容易导致错误，另一方面，你实际上并不需要这么做。使用场景由于调用load方法时的环境很不安全，我们应该尽量减少load方法的逻辑。另一个原因是load方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在load方法中。一个常见的使用场景是在load方法中实现Method Swizzle： 1234567// In Other.m+ (void)load &#123; Method originalFunc = class_getInstanceMethod([self class], @selector(originalFunc)); Method swizzledFunc = class_getInstanceMethod([self class], @selector(swizzledFunc)); method_exchangeImplementations(originalFunc, swizzledFunc);&#125; 在Child类的load方法中，由于还没调用Other的load方法，所以输出结果是”Original Output”，而在main函数中，输出结果自然就变成了”Swizzled Output”。一般来说，除了Method Swizzle，别的逻辑都不应该放在load方法中实现。initialize这个方法在第一次给某个类发送消息时调用（比如实例化一个对象），并且只会调用一次。initialize方法实际上是一种惰性调用，也就是说如果一个类一直没被用到，那它的initialize方法也不会被调用，这一点有利于节约资源。调用规则与load方法类似的是，在initialize方法内部也会调用父类的方法，而且不需要我们显示的写出来。与load方法不同之处在于，即使子类没有实现initialize方法，也会调用父类的方法，这会导致一个很严重的问题：// In Parent.m+ (void)initialize { NSLog(@”Initialize Parent, caller Class %@”, [self class]);}// In Child.m// 注释掉initialize方法// In main.mChild *child = [Child new];运行后发现父类的initialize方法竟然调用了两次：2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Parent2016-02-01 22:57:02.985 load[12772:1509345] Initialize Parent, caller Class Child这是因为在创建子类对象时，首先要创建父类对象，所以会调用一次父类的initialize方法，然后创建子类时，尽管自己没有实现initialize方法，但还是会调用到父类的方法。虽然initialize方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用initialize方法的姿势如下：// In Parent.m+ (void)initialize { if (self == [Parent class]) { NSLog(@”Initialize Parent, caller Class %@”, [self class]); }}加上判断后，就不会因为子类而调用到自己的initialize方法了。使用场景initialize方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如NSMutableArray这种类型的实例化依赖于runtime的消息发送，所以显然无法在编译器初始化： 12345678910// In Parent.mstatic int someNumber = 0; // int类型可以在编译期赋值static NSMutableArray *someObjects;+ (void)initialize &#123; if (self == [Parent class]) &#123; // 不方便编译期复制的对象在这里赋值 someObjects = [[NSMutableArray alloc] init]; &#125;&#125; 总结1 load和initialize方法都会在实例化对象之前调用，以main函数为分水岭，前者在main函数之前调用，后者在main函数之后并且给对象发消息（实例化或者调用+方法）时候调用。这两个方法会被自动调用，不能手动调用它们。。 load和initialize方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类。 load方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量。 load和initialize方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。 总结2+load 首先，load方法是一定会在runtime中被调用的，只要类被添加到runtime中了，就会调用load方法，所以我们可以自己实现laod方法来在这个时候执行一些行为。 而且有意思的一点是，load方法不会覆盖。也就是说，如果子类实现了load方法，那么会先调用父类的load方法，然后又去执行子类的load方法。同样的，如果分类实现了load方法，也会先执行主类的load方法，然后又会去执行分类的load方法。所以父类的load会执行很多次，这一点需要注意。而且执行顺序是 类 -&gt; 子类 -&gt;分类。而不同类之间的顺序不一定。 +initialize 与load不同的是，initialize方法不一定会执行。只有当一个类第一次被发送消息的时候会执行，注意是第一次。什么叫发送消息呢，就是执行类的一些方法的时候。也就是说这个方法是懒加载，没有用到这个类就不会调用，可以节省系统资源。 还有一点截然相反，却更符合我们预期的就是，initialize方法会覆盖。也就是说如果子类实现了initialize方法，就不会执行父类的了，直接执行子类本身的。如果分类实现了initialize方法，也不会再执行主类的。所以initialize方法的执行覆盖顺序是 分类 -&gt; 子类 -&gt;类。且只会有一个initialize方法被执行。 原文1,原文2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swift报错UICollectionView must be initialized with a non-nil layout parameter]]></title>
      <url>%2F2017-05-05-swift%E6%8A%A5%E9%94%99UICollectionView%20must%20be%20initialized%20with%20a%20non-nil%20layout%20parameter.html</url>
      <content type="text"><![CDATA[今天学习swift的UICollectionView时候项目运行就报错，控制台显示“UICollectionView must be initialized with a non-nil layout parameter”，意思很明显就是UICollectionView初始化时候没有给个有效的layout，就是说UICollectionViewFlowLayout没有初始化，我就纳闷了明明是初始化了啊 123全局变量 private var layout = UICollectionViewFlowLayout() private var collectionView :UICollectionView() 然后在viewDidLoad里 1collectionView = UICollectionView(frame: self.view.bounds, collectionViewLayout: layout) 看起来没什么问题，才初学swift不知道 1private var collectionView :UICollectionView() 这样写已经是初始化了，所以就报错了，应该在声明变量的时候改为如下写法 1private var collectionView :UICollectionView! 这样就就只是声明变量了再在viewDidLoad里初始化使用就没问题了 12 layout = UICollectionViewFlowLayout()collectionView = UICollectionView(frame: self.view.bounds, collectionViewLayout: layout)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ios9设置通用链接]]></title>
      <url>%2F2017-04-26-ios9%E8%AE%BE%E7%BD%AE%E9%80%9A%E7%94%A8%E9%93%BE%E6%8E%A5.html</url>
      <content type="text"><![CDATA[什么是通用链接？通过唯一的网址, 就可以链接一个特定的视图到你的 APP 里面, 不需要特别的 schema通用链接是一种能够方便的通过传统 HTTP 链接来启动 APP, 使 用相同的网址打开网站和 APP。当你的应用支持通用链接，iOS9 之后 , 用户可以点击一个链接跳转到你的网站,并获得无缝重定向到您安装的应用程序,而无需通过 Safari 浏览器。如果你的应用不支持的话,点击链接将会用 Safari 来打开。。试想一下 Twitter 使用了通用链接, 那么你每在 twitter.com 点击一个链接, 你的 iOS 设备都会在 Twitter 里面自动打开这个页面, 而不是当你没有安装时转到普通的网页。这个用户体验是顺畅的, 最重要的是用户不会失去上下文（跳到 APP 后 Safari 上不再留下空标签）。 通用链接的优点通用链接比自定义的URL链接有几处尤为突出的好处,具体来说,通用链接独特性：与自定义的URL链接相比,通用链接不能被其他的应用程序所访问,因为 1:它们使用的是标准的HTTP 或 HTTPS 链接到你的网站。安全性：当用户安装应用程序,iOS会检查您已经上传到web服务器文件,以确 2:保您的网站允许你的应用程序能打开代表它的URL 文件,只要你创建并且上传该文件,那么你的应用和服务器之间的关联是安全的。灵活性：当你的应用程序没有被安装的时候,通用链接照样能够工作。 3:当用户没有安装你的应用程序,点击该链接,将会以用户所期望的以Safari的形式访问。简单性：通用链接既能支持你的网站,又能支持你的应用私有性：其他的应用程序能和你的应用程序通信,不管你的应用是否被安装。 准备使用通用链接实现通用链接不难, 但首先必须遵守一些先决条件。如下： 有一个注册的域名 通过 SSL 访问域名 支持上传一个 JSON 文件到你的域名 至少 iOS 9 beta 2 版本 [下载]，这很重要,因为如果是之前的测试版本你需要做额外的操作。 至少 Xcode 7 beta 2如果你都有了, 那就来按照下面3个步骤来做吧。 1.开启 Associated Domains 域: 进入苹果Apple Developer — Member Center - Certificates, Identifiers &amp; Profiles – Identifiers - App IDs –Edit 然后开启打钩 Associated Domains 后保存。 2.添加域名到 Capabilities首先, 你必须在 Xcode 的 capabilities 里 添加你的 APP 域名, 必须用 applinks: 前置它：还添加一些你可能拥有的子域和扩展（www.domain.com, news.domain.com 等等）。 用applinks: 前缀添加所有域名, 同时不要忘了包含所有可能需要的子域名 这将使你的 APP 从你的域名请求一个特殊的 JSON 文件 apple-app-site-association。当你第一次启动 APP，它会从 https://domain.com/apple-app-site-association 下载这个文件。跳到下个步骤来了解如何构建这个文件。 3.上传 apple-app-site-association 文件该文件必须存在且为了安全原因可使用 SSL 通过 GET 请求访问到。你可以打开一个文本编辑器然后写一个这样的简单 JSON 格式： 123456789101112131415&#123; &quot;applinks&quot;: &#123; &quot;apps&quot;: [], &quot;details&quot;: [ &#123; &quot;appID&quot;: &quot;L2LYHXGC7E.com.domain.Appr&quot;, &quot;paths&quot;: [ &quot;*&quot; ,&quot;/&quot;,&quot;/archives/&quot;,&quot;/archives/*&quot;] &#125;, &#123; &quot;appID&quot;: &quot;ABCD1234.com.apple.wwdc&quot;, &quot;paths&quot;: [ &quot;*&quot; ] &#125; ] &#125;&#125; 最后, 上传这个文件到你的域名根目录。如果你打开 https://domain.com/apple-app-site-association 可以看到你的文件, 我看到网上一部分人说可以打开苹果的这个网址检测apple-app-site-association是否是有效，在我部署完以上步骤后测试下最后一项Link to Application也是无效的但在我做完所有步骤后发现已经实现了本文要实现的功能，也就是说具体效果还是要以自己测试为准。那么你就可以继续下一步了。 注意事项（1） 1, paths 路径是大小写敏感的 2, paths 内容可明确哪些通用链接需要被处理,哪些不需要 3, NOT 使用:为了明确指出不被处理的链接,可增加 “NOT”在链接前面例 如 “paths”: [ “/wwdc/news/“, “NOT /videos/wwdc/2010/“, “/videos/wwdc/201?/“] 4, 你可以使用 * 明确所有的网页 5, 也可以使用一个明确的的 URL,例如 /wwdc/news/ 6, 也可以追加 到你的 URL ,例如 /videos/wwdc/2015/ 也可以使用 来匹配任何字符,使用 ? 来匹配一个字符,可以在路径 中使用这种混搭的形式, 例如 /foo//bar/201?/mypage 注意事项（2） 1, “appID”组成部分:TeamID + BundleId TeamID 2, BundleId 一定要和 APP 的 BundleId 一致。 3, apple-app-site-association 文件不能带后缀 4, apple-app-site-association 文件需要上传到网站根目录 5, 每一个代表着应用的 字典,必须包含一个 appID 和 paths, appID 是teamID 和 bundleID,paths 是一个字符串的数组明确着你的应用支持的通用链接和你的应用程序不支持的通用连接内容。 下图就是 “appID”组成部分:TeamID + BundleId TeamID 最后为了在 APP 里支持通用链接, 你需要在 AppDelegate 里实现相对应的逻辑 附上我那个验证apple-app-site-association的截图吧B6B1BAB7-FBDD-4CFD-8862-9B78738787E4 posted by (C)sky521 效果图 在“全聚星”打开 IMG_0413 posted by (C)sky521]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决xcode8.2控制台数据打印不全]]></title>
      <url>%2F2017-04-25-%E8%A7%A3%E5%86%B3xcode8-2-NSlog%E6%95%B0%E6%8D%AE%E6%89%93%E5%8D%B0%E4%B8%8D%E5%85%A8.html</url>
      <content type="text"><![CDATA[最近升级Xcode8，开发工具出现了，控制台log数据不完整，经常打印一半，就没有了，经过查询一番终于找到了解决办法! 解决办法：宏定义去log日志数据，把NSlog换成print 123456789#ifdef DEBUG#define DLog( s, ... ) printf(&quot;class: &lt;%p %s:(%d) &gt; method: %s \n%s\n&quot;, self, [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String], __LINE__, __PRETTY_FUNCTION__, [[NSString stringWithFormat:(s), ##__VA_ARGS__] UTF8String] )#else#define DLog( s, ... )#endif 日了狗了 让我纠结半天 ，心想xcode不会出现这么低级的问题吧，没想查了一下还真有这个问题，事实证明‘实践是证明真理的唯一标准’啊。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决TableViewCell和CollectionViewCell复用布局错乱问题]]></title>
      <url>%2F2017-03-30-%E8%A7%A3%E5%86%B3TableViewCell%E5%92%8CCollectionViewCell%E5%A4%8D%E7%94%A8%E5%B8%83%E5%B1%80%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[解决TableViewCell和UICollectionViewCell使用过程中因为重用机制问题造成数据重复显示或者布局错乱问题。 常规配置如下 当超过tableView显示的范围的时候 后面显示的内容将会和前面重复 123456789101112131415161718192021// 这样配置的话超过页面显示的内容会重复出现- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义唯一标识 static NSString *CellIdentifier = @&quot;Cell&quot;; // 通过唯一标识创建cell实例 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125;//通过以下3方案可以解决 方案一： 让每个cell都拥有一个对应的标识 这样做也会让cell无法重用 所以也就不会是重复显示了 显示内容比较多时内存占用也是比较多的 123456789101112131415161718/ /方案一 通过不让他重用cell 来解决重复显示 不同的是每个cell对应一个标识- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义cell标识 每个cell对应一个自己的标识 NSString *CellIdentifier = [NSString stringWithFormat:@&quot;cell%ld%ld&quot;,indexPath.section,indexPath.row]; // 通过不同标识创建cell实例 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125; 方案二： 同样取消cell的重用机制，通过indexPath来创建cell 将可以解决重复显示问题 不过这样做相对于大数据来说内存就比较吃紧了 123456789101112131415161718// 方案二 通过不让他重用cell 来解决重复显示- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义唯一标识 static NSString *CellIdentifier = @&quot;Cell&quot;; // 通过indexPath创建cell实例 每一个cell都是单独的 UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125; ###方案三 只要最后一个显示的cell内容不为空，然后把它的子视图全部删除，等同于把这个cell单独出来了 然后跟新数据就可以解决重复显示 12345678910111213141516171819202122232425// 方案三 当页面拉动需要显示新数据的时候，把最后一个cell进行删除 就有可以自定义cell 此方案即可避免重复显示，又重用了cell相对内存管理来说是最好的方案 前两者相对比较消耗内存- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 定义唯一标识 static NSString *CellIdentifier = @&quot;Cell&quot;; // 通过唯一标识创建cell实例 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; // 判断为空进行初始化 --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化） if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier]; &#125; else//当页面拉动的时候 当cell存在并且最后一个存在 把它进行删除就出来一个独特的cell我们在进行数据配置即可避免 &#123; while ([cell.contentView.subviews lastObject] != nil) &#123; [(UIView *)[cell.contentView.subviews lastObject] removeFromSuperview]; &#125; &#125; // 对cell 进行简单地数据配置 cell.textLabel.text = @&quot;text&quot;; cell.detailTextLabel.text = @&quot;text&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;4.png&quot;]; return cell;&#125; 经过测试UIcollectionViewCell布局错乱用第一种方法同样可以解决问题，实际解决情况还要自己测试才可以。 最后贴一个我的UIcollectionViewCell解决复用的代码 123456789101112- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; NSString *CellIdentifier = [NSString stringWithFormat:@&quot;cell%ld%ld&quot;,indexPath.section,indexPath.row]; [self.collectionView registerNib:[UINib nibWithNibName:@&quot;AudienceViewCollectionViewCell&quot; bundle:nil] forCellWithReuseIdentifier:CellIdentifier]; // 通过不同标识创建cell实例 AudienceViewCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:CellIdentifier forIndexPath:indexPath]; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift函数与闭包的应用实例]]></title>
      <url>%2F2017-03-29-Swift%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B.html</url>
      <content type="text"><![CDATA[今天的博客算是比较基础的，还是那句话，基础这东西在什么时候都是最重要的。说到函数，只要是写过程序就肯定知道函数是怎么回事，今天就来讨论一下Swift中的函数的特性以及Swift中的闭包。今天的一些小实例中回类比一下Objective-C中的函数的写法等等。Swift中的函数还是有许多好用的特性的，比如输入参数，使用元组返回多个值， 定义形参名，设定默认参数以及可变参数等等一些好用的特性。而在Swift中的闭包就是Objective-C中的Block, 除了语法不通外，两者的用法是一样的。废话少说，开始今天的主题，先搞一搞Swift中的函数，然后在搞一搞Swift中的闭包。 一.Swift中的函数 1. 函数的定义与使用 在介绍Swift中的函数之前，我想用Objective-C中的一个简单的加法函数来作为引子，然后类比着实现一下Swift中相同功能的函数。关于函数定义就比较简单了，就是一些语法的东西，下面的代码片段是Objc中求两个整数之和的函数，并返回两个数的和。- (NSInteger)sumNumber1:(NSInteger) number1 number2:(NSInteger) number2 { return number1 + number2;} 函数的功能比较简单了，就是把两个整数传进来，然后返回两个整数的和。接下来将用Swift语言实现，也好通过这个实例来熟悉一下Swift语言中定义函数的语法。下方是Swift语言中求两个整数之和的函数。语法比较简单了，在Swift中定义函数，我们会使用到关键字func来声明函数。1 //函数定义2 func sum (number1:Int, number2:Int) -&gt; Int{3 return number1 + number2;4 } 用文字来描述Swift定义基本函数的语法就是: func 函数名 （形参列表） -&gt; 返回值类型 { 函数体}，这样你就可以定义一个函数了。当然，函数定义时还有好多其他的用法，下面会详细介绍。上面函数的调用方法如下：1 let sumTwoNubmer = sum(2, number2: 3);&nbsp; 2. 函数中的形参列表 关于函数中的形参列表还是有必要提上一嘴的，因为形参列表作为函数数据源之一，所以把参数列表好好的搞一搞还是很有必要的。参数列表也有很多好用的使用方式，接下来详细的介绍一下函数的形参列表。 (1) 默认的形参是常量（let） 在函数的形参列表中，默认的形参是常量。也就是相当于用let关键字对形参进行修饰了。我们可以做个试验，把上面加法函数做一个修改，在加法函数中对number1进行加1操作，你会得到一个错误，这个错误的大体意思就是&ldquo;number1是不可被修改的，因为它是let类型的常量&rdquo;。并且编译器还给人出了Fix-it（修复）的方案，就是在number1前面使用var关键字进行修饰，使其成为变量，这样才可以修改其值。 上面说这么多，一句话：形参默认是常量，如果你想让其是变量，那么你可以使用var关键字进行修饰，这样被关键字var修饰的变量在函数中就可以被修改。下方就是报的这个错误，和编译器提供的解决方案。（在Objc中默认可以在函数中改变形参的值）&nbsp; （2）给形参命名 为了代码的可读性和可维护性，我们在定义函数时，需要为每个参数名一个名字，这样调用者见名知意，很容易就知道这个参数代表什么意思了。接下来还是在上述加法函数中进行修改，为每个参数名一个名字，并看一下调用方式。修改上面的函数，给第一个形参命名成numberOne, 第二个形参为numberTwo, 下方是修改后的函数。 紧接着sum()函数的调用方式也会有所改变，在调用函数时编译器会给出参数的名称，这样调用者一目了然。1 //函数定义2 func sum (numberOne number1:Int, numberTwo number2:Int) -&gt; Int{3 return number1 + number2;4 }56 let sumTwoNubmer = sum(numberOne: 10, numberTwo: 20); &nbsp;调用上述函数时，下方是编译器给出的提示，一目了然呢。 关于Swift中参数名的内容，要说明的是在Swift1.0的时候，你可以在参数前面添加上#号，然后参数名就与变量（或者常量）的名字相同，而Swift2.0后这个东西去掉了，因为默认就相当于Swift1.0中添加#号。&nbsp; (3) 函数的传参与传引用 先暂且这么说着，在C语言的函数中可以给函数传入参数，或者传入实参的内存地址就是所谓的传引用。如果传入的是引用的话，在函数中对值进行修改的话，那么出了函数，这个被修改的值是可以被保留的。在Swift中也是可以的，不过你需要使用inout关键字修饰形参，并且在使用该函数时，用&amp;来修饰。这一点和C语言中类似，&amp;就是取地址符。下方是inout使用的一个小实例。1 func incrementStepTwo (inout myNumber:Int) {2 myNumber += 23 }4 var myTestNumber = 65 incrementStepTow(&amp;myTestNumber) //myTestNumber = 8 myTestNumber变量经过incrementStepTwo()函数后，其值就会增加2。当然前提是myTestNumber是变量，如果myTestNumber是常量的话，那么对不起，调用该函数就会报错，下面是把var改成let后IDE给的错误提示。错误原因很显然是你动了一个不该动的值，也就是常量不可再次被修改的。&nbsp; (4) 不定参数函数 不定参数函数也就是形参的个数是不定的，但是形参的类型必须是相同的。不定形参在使用时怎么取呢？不定个数的形参实际上是一个数组，我们可以通过for循环的形式来遍历出每个形参的值，然后使用就可以了。下方incrementMultableAdd()函数的形参的个数是不定的，其功能是求多个整数的和。在函数中我们只需遍历每个参数，然后把每个参数进行相加，最后返回所求的和即可。函数比较简单，再此就不在啰嗦了。&nbsp; (5) 默认形参值 在Swift语言中是支持给形参赋初始值的，这一点在其他一些编程语言中也是支持的。但是Objective-C这么看似古老的语言中就不支持给形参指定初始值，在Swift这门现代编程语言中是支持这一特性的。默认参数要从参数列表后开始为参数指定默认值，不然就会报错。下方就是为函数的形参指定默认参数的示例。一个表白的方法sayLove(), 形参youName默认是&ldquo;山伯&rdquo;， 形参loverName默认是&ldquo;英台&rdquo;。 紧接着是sayLove函数的三种不同的调用方式，在调用函数时你可以不传参数，可以传一个参数，当然传两个也是没问题的。&nbsp; 因为函数的每个参数都是有名字的，在含有默认参数的函数调用时，可以给任意一个参数进行传值，其他参数取默认值，这也是Swift的一大特色之一，具体请看如下简单的代码示例：&nbsp; 3.函数类型 每个函数都有自己的所属类型，函数类型说白了就是如果两个函数参数列表相同以及返回值类型相同，那么这两个函数就有着相同的函数类型。在Swift中可以定义一个变量或者常量来存储一个函数的类型。接下来将用过一个实例还介绍一下函数类型是个什么东西。 &nbsp; (1) 首先创建两个函数类型相同的函数，一个函数返回两个整数的差值，另一个函数返回两个整数的乘积。当然这两个函数比较简单，直接上代码：1 //现定义两个函数类型相同的函数2 func diff (number1:Int, number2:Int) -&gt; Int {3 return number1 - number2;4 }56 func mul (number1:Int, number2:Int) -&gt; Int {7 return number1 number2;8 } (2) 函数定义好后，接着要定义个一个枚举来枚举每种函数的类型，下面定义这个枚举在选择函数时会用到，枚举定义如下：1 //定义两种计算的枚举类型2 enum CountType:Int {3 case DiffCount = 04 case MulCount5 } (3) 接下来就是把(1)和(2)中定义的东西通过一个函数来组合起来。说白了，就是定义个函数来通过枚举值返回这个枚举值所对应的函数类型。有时候说多了容易犯迷糊，就直接上代码得了。下方函数的功能就是根据传进来的枚举值来返回相应的函数类型。 1 //选择类型的函数，并返回相应的函数类型 2 func choiseCountType(countType:CountType) -&gt; ((Int, Int) -&gt; Int) { 3 //函数类型变量 4 var myFuncType:(Int, Int) -&gt; Int 5 6 switch countType { 7 case .DiffCount: 8 myFuncType = diff 9 case .MulCount:10 myFuncType = mul11 }12 return myFuncType;13 } (4) 接下来就是使用(3)中定义的函数了，首先我们需要定义一个相应函数类型((Int, Int) -&gt; Int)的变量来接收choiseCountType()函数中返回的函数类型，然后调用该函数类型变量，在Playground中执行的结果如下：&nbsp; &nbsp; &nbsp;4.函数嵌套 我们可以把 3 中的代码使用函数嵌套进行重写，在Swift中是支持函数嵌套的。 所以可以吧3.1和3.2中的函数放到3.3函数中的，所以我们可以对上述代码使用函数嵌套进行重写。使用函数嵌套重写后的代码如下所示，当然，choiseCountType()函数的调用方式没用发生改变，重写后的调用方式和3.4中的调用方式是一样一样的。 1 //选择类型的函数，并返回相应的函数类型 2 func choiseCountType(countType:CountType) -&gt; ((Int, Int) -&gt; Int) { 3 4 //现定义两个函数类型相同的函数 5 func diff (number1:Int, number2:Int) -&gt; Int { 6 return number1 - number2; 7 } 8 9 func mul (number1:Int, number2:Int) -&gt; Int {10 return number1 number2;11 }121314 //函数类型变量15 var myFuncType:(Int, Int) -&gt; Int1617 switch countType {18 case .DiffCount:19 myFuncType = diff20 case .MulCount:21 myFuncType = mul22 }23 return myFuncType;24 }&nbsp; 二. 闭包 说道Swift中的闭包呢，不得不提的就是Objective-C中的Block, 其实两者是一个东西，使用方式以及使用场景都是相同的。我们完全可以类比着Objective-C中的Block来介绍一下Swift中的Closure（闭包）。其实就是匿名函数。接下来的这段内容，先介绍一下Swift中Closure的基本语法，然后在类比着ObjC中的Block窥探一下Closure的使用场景。 1.Closure变量的声明 Closure就是匿名函数，我们可以定义一个闭包变量，而这个闭包变量的类型就是我们上面介绍的&ldquo;函数类型&rdquo;。定义一个闭包变量其实就是定义一个特定函数类型的变量，方式如下。因为Closure变量没有赋初始值，所以我们把其声明为可选类型的变量。在使用时，用!强制打开即可。1 var myCloure0:((Int, Int) -&gt; Int)? 除了上面的方式外，我们还用另一种常用的声明闭包变量的方式。那就是使用关键字typealias定义一个特定函数类型，我们就可以拿着这个类型去声明一个Closure变量了，如下所示1 //定义闭包类型 (就是一个函数类型)2 typealias MyClosureType = (Int, Int) -&gt; Int3 var myCloure:MyClosureType?&nbsp; 2. 给Closure变量赋值 给Closure变量赋值，其实就是把一个函数体赋值给一个函数类型的变量，和函数的定义区别不大。但是给闭包变量赋值的函数体中含有参数列表，并且参数列表和真正的函数体之间使用关键字in来分割。 闭包可选变量的调用方式与普通函数没什么两样，唯一不同的是这个函数需要用!来强制打开才可以使用。赋值和调用方式如下。&nbsp; 3. 闭包回调的应用实例 暂且先称作闭包回调吧，其实就是Objc中的Block回调。在Swift中的闭包回调和Objc中的Block回调用法一致，下方将会通过一个实例来介绍一下闭包的应用之一。下方会创建两个视图控制器，我们暂且称为FirstViewController和SecondViewController。在FirstViewController上有一个Label和一个Button, 这个Button用来跳转到SecondViewController, 而这个Label用来显示从SecondViewController中回调过来的值。 而SecondViewController也有一个TextField和一个Button, 点击Button就会把输入框中的值通过闭包回调回传到FirstViewController然后在FirstViewController上的Label显示。 (1) 构建这个实例的第一步要做的就是使用Stroyboard把我们所需的控件布局好，并且管理相应的类。当然我们这个Demo的重点不在于如何去布局控件，如何去关联控件，以及如何去使用控件，所以上述的这些就不做赘述了。这个实例的重点在于如何使用Closure实现值的回调。下方是我们的控件布局和目录结构的截图，从Storyboard上的控件来看，功能也就一目了然了。点击&ldquo;FirstViewController&rdquo; 上的&ldquo;Go SecondViewController&rdquo;按钮，就会跳转到 &ldquo;SecondViewController&rdquo; 。 在SecondViewController视图上的输入框输入数值，点击Back按钮返回到FirstViewController, 同时把输入框中的文本通过闭包回调的形式回传过来在FristViewController的label上显示。大致就这个简单的功能。&nbsp; （2）FirstViewController.swift中的内容 FirstViewController.swift中的内容比较简单，就关联一个Label控件和一个按钮点击的事件，点击按钮就会跳转到SecondViewController，具体代码如下，在此就不啰嗦了，请看代码中的注释。下方代码重要的一点是在跳转到SecondViewController时要实现其提供的闭包回调，以便接受回传过来的值。 1 // 2 // FirstViewController.swift 3 // SwiftDemo 4 // 5 // Created by Mr.LuDashi on 15/11/18. 6 // Copyright &copy; 2015年 ZeluLi. All rights reserved. 7 // 8 9 import UIKit1011 class FirstViewController: UIViewController {1213 @IBOutlet var showTextLabel: UILabel! //展示回调过来的文字信息1415 override func viewDidLoad() {16 super.viewDidLoad()17 }1819 override func didReceiveMemoryWarning() {20 super.didReceiveMemoryWarning()21 }2223 //点击按钮跳转到SecondViewController24 @IBAction func tapGoSecondViewControllerButton(sender: UIButton) {25 //从Storyboard上加载SecondViewController26 let secondVC = UIStoryboard(name: “Main”, bundle: NSBundle.mainBundle()).instantiateViewControllerWithIdentifier(“SecondViewController”)as! SecondViewController2728 //实现回调，接收回调过来的值29 secondVC.setBackMyClosure { (inputText:String) -&gt; Void in30 self.showTextLabel.text = inputText31 }3233 //push到SecondViewController34 self.navigationController?.pushViewController(secondVC, animated: true)35 }36 }&nbsp; (3) SecondViewController.swift中的内容 SecondViewController.swift中的内容也不麻烦，就是除了关联控件和事件外，还定义了一个闭包类型（函数类型），然后使用这个特定的函数类型声明了一个此函数类型对应的变量。我们可以通过这个变量来接受上个页面传过来的闭包体，从而把用户输入的值，通过这个闭包体回传到上个页面。具体代码实现如下： 1 // 2 // SecondViewController.swift 3 // SwiftDemo 4 // 5 // Created by Mr.LuDashi on 15/11/18. 6 // Copyright &copy; 2015年 ZeluLi. All rights reserved. 7 // 8 9 import UIKit1011 typealias InputClosureType = (String) -&gt; Void //定义闭包类型（特定的函数类型函数类型）1213 class SecondViewController: UIViewController {1415 @IBOutlet var inputTextField: UITextField! //输入框，让用户输入值，然后通过闭包回调到上一个页面1617 var backClosure:InputClosureType? //接收上个页面穿过来的闭包块1819 override func viewDidLoad() {20 super.viewDidLoad()21 }2223 override func didReceiveMemoryWarning() {24 super.didReceiveMemoryWarning()25 }2627 //闭包变量的Seter方法28 func setBackMyClosure(tempClosure:InputClosureType) {29 self.backClosure = tempClosure30 }3132 @IBAction func tapBackButton(sender: UIButton) {33 if self.backClosure != nil {34 let tempString:String? = self.inputTextField.text35 if tempString != nil {36 self.backClosure!(tempString!)37 }38 }39 self.navigationController!.popViewControllerAnimated(true)40 }41 }&nbsp; (4) 经过上面的步骤这个实例已经完成，接下来就是看一下运行效果的时间了。本来想做成Git动态图的，感觉实例功能简单，而且UI上也比较简单，就没做，还是看截图吧。运行效果的截图如下： 4.数组中常用的闭包函数 在Swift的数组中自带了一些比较好用的闭包函数，例如Map, Filter, Reduce。接下来就好好的看一下这些闭包，用起来还是比较爽的。 (1) Map(映射) 说到Map的用法和功能，不能不说的是如果你使用过ReactiveCocoa框架，那么对里边的Sequence中的Map的使用方式并不陌生。其实两者的使用方法和功能是极为相似的。如果你没使用过RAC中的Map，那也无关紧要，接下来我们先上段代码开看一下数组中的Map闭包函数。 通过上面的代码段以及运行结果，我们不难看出，map闭包函数的功能就是对数组中的每一项进行遍历，然后通过映射规则对数组中的每一项进行处理，最终的返回结果是处理后的数组（以一个新的数组形式出现）。当然，原来数组中的元素值是保持不变的，这就是map闭包函数的用法与功能。&nbsp;&nbsp; (2) Filter (过滤器) Filter的用法还是比较好理解的，Filter就是一个漏勺，就是用来过滤符合条件的数据的。在ReactiveCocoa中的Sequence也是有Filter的，用法还是来过滤Sequence中的数据的。而在数组中的Filter用来过滤数组中的数据，并且返回新的数组，新的数组中存放的就是符合条件的数据。Filter的用法如下实例，下方的实例就是一个身高的过滤，过滤掉身高小于173的人，返回大于等于173的身高数据。 （3）Reduce&nbsp; 在ReactiveCocoa中也是有Reduce这个概念的，ReactiveCocoa中使用Reduce来合并消减信号量。在swift的数组中使用Reduce闭包函数来合并items, 并且合并后的Value。下方的实例是一个Salary的数组，其中存放的是每个月的薪水。我们要使用Reduce闭包函数来计算总的薪水。下方是DEMO的截图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift字符串常用操作]]></title>
      <url>%2F2017-03-28-Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C.html</url>
      <content type="text"><![CDATA[swift 中关于取子串有4 个方法 str.index(after: String.Index) str.index(before: String.Index) str.index(String.Index, offsetBy: String.IndexDistance) str.index(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index) 分别是什么, 该如何使用?下面来看看本例中, 我们创建一个字符串"Hello, playground" , 如下 var str = "Hello, playground" 字符索引 startIndex 和 endIndex startIndex 是第一个字符的索引, 也就是 endIndex 是最后一个字符索引 +1 // character str[str.startIndex] // H str[str.endIndex] // error: after last character // range let range = str.startIndex ..&lt; str.endIndex str[range] // "Hello, playground" after index(after: String.Index)after 指向给定索引后面的一个索引(类似与 + 1) // character let index = str.index(after: str.startIndex) str[index] // "e" // range let range = str.index(after: str.startIndex)..&lt;str.endIndex str[range] // "ello, playground" before index(before: String.Index)before 指向给定索引之前的一个索引(类似与 - 1) // character let index = str.index(before: str.endIndex) str[index] // d // range let range = str.startIndex ..&lt; str.index(before: str.endIndex) str[range] // Hello, playgroun offsetBy index(String.Index, offsetBy: String.IndexDistance)offsetBy 的值可以为正或是负, 正则表示向后, 负则相反.别被offsetBy 的 String.IndexDistance 类型吓到, 本身其实是一个 Int.(类似于+n 和 -n) // characterlet index = str.index(str.startIndex, offsetBy: 7)str[index] // p // rangelet start = str.index(str.startIndex, offsetBy: 7)let end = str.index(str.endIndex, offsetBy: -6)let range = start ..&lt; endstr[range] // play limitedBy index(String.Index, offsetBy: String.IndexDistance, limitedBy: String.Index) limitedBy 在 offset 过大导致溢出错误的时候很有用.这个返回值是一个可选值, 如果 offsetBy 超过了 limitBy, 则返回 nil. // characterif let index = str.index(str.startIndex, offsetBy: 7, limitedBy: str.endIndex) {str[index] // p} 上面这段代码中如果offset 设置为 77, 返回值就是 nil, if 中的代码就会跳过 所以如果你要取子串的正确姿势是什么? 取某个位置之后的所有字符str.substring(from: str.index(str.startIndex, offsetBy: 7)) // playground取倒数某个位置之后的所有字符str.substring(from: str.index(str.endIndex, offsetBy: -10)) //playground取某个位置之前的所有字符str.substring(to: str.index(str.startIndex, offsetBy: 5)) //Hello取倒数某个位置之前的所有字符str.substring(to: str.index(str.endIndex, offsetBy: -12)) //Hello取中间的某个字符串str.substring(with: str.index(str.startIndex, offsetBy: 7) ..&lt; str.index(str.endIndex, offsetBy: -6)) // play]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[myResume]]></title>
      <url>%2F2017-03-16-myResume.html</url>
      <content type="text"><![CDATA[简历预览王森男|未婚|1992年2月生| 户口：河南-南阳| 现居住于:北京-朝阳区2.5年工作经验 |团员Tel:15617877692 E-mail：sslxws@163.com求职意向工作性质：全职期望职业：iOS开发工程师期望行业：互联网技术开发工作地区：北京期望月薪：面议目前状况：我目前在职，正考虑换个新环境（如有合适的工作机会，到岗时间2个星期左右）专业技能1.熟练掌握Object-C、Swift语言开发，熟悉C语言、html、css，以及JavaScprit的简单使用2.熟悉 runtime 以及 runloop3. 熟悉并掌握多线程技术，如 NSThread、GCD、NSOpeartion；4.熟悉MRC ARC 内存管理机制5.熟练使用Core Animation、UIView开发动画6.熟练使用WebStorm并掌握H5与iOS交互7.熟练掌握百度地图、高德地图的定位、导航、自定义标注、地理编码等功能。 8.熟练使用支付宝支付、微信支付、银联支付等多种支付方式。9.熟练使用推送通知，自定义消息的处理。10.掌握Instruments leaks内存检测以及单元测试提升程序的稳定性。11.熟练使用各种设计模式，如MVC 模式（MVVM模式）、代理模式、单例模式、观察者模式等设计模式 12.熟练使用AFNetworking、SDWebImage,Masonry第三方框架13. 熟悉 SourceTree、Github 代码管理工具,jenkins可持续开发自我评价对于iOS的技术水平可以单独做完整个项目,负责各个模块的开发调试。有较强的学习能力和探索精神。工作经历2016/06 – 至今 北京易聚创意科技有限公司|iOS开发工程师 行业类别： 互联网/电子商务|规模：100-499人|职位月薪：15000-25000元/月工作描述：带领团队共同开发‘全聚星’直播App，搭建gitlab代码管理工具配置环境，搭建禅道项目管理Bug反馈处理工具，搭建Jenkins持续集成配置环境，设计项目框架；实现直播模块，商城模块，私信聊天；辅助其他开发成员解决疑难问题，修复Bug,根据开发日期分配任务2015/09 – 2016/05北京青籁科技有限公司|iOS工程师 行业类别： 互联网/电子商务|规模：100-499人|职位月薪：10001-15000元/月工作描述： 独立开发“理大师”app的用户端，负责整个项目的框架、逻辑处理以及各个模块的开发，地图定位 poi 搜索 导航，微信支付和支付宝支付，推送通知，配合后台和web前端交互处理h5界面，维护升级。 实现一个可以在线预约下单上门推拿的健康医疗服务。（包含用户端与医生端）2014/10 – 2015/09北京溥联信息科技有限公司|iOS开发实习生 行业类别： 互联网/电子商务|企业性质：事业单位|规模：20-99人|职位月薪：6001-8000元/月工作描述：快停App手机端的开发，根据需求进行iOS平台客户端软件的开发和维护,设计项目框架，实现界面展示与后台调试api完善项目功能，维护升级。 实现了一个可以快速停车为车主提供便捷精准可靠的停车服务（精准定位，预约停车，停车导航，智能计时，在线支付） 业绩描述：负责项目所有板块的开发， 独自解决快停App首页加载地图自定义上千个标注点的卡顿现象，实现区域标注点与全局标注点的切换，提高程序的流畅度，提升用户体验。离职原因：项目经验2016/06 – 至今 全聚星直播责任描述：带领iOS开发组共同开发‘全聚星’直播App，搭建gitlab代码管理工具配置环境，搭建禅道项目管理Bug反馈处理工具，搭建Jenkins持续集成配置环境，设计项目框架；实现直播模块，商城模块，私信聊天；辅助其他开发成员解决疑难问题，修复Bug,根据开发日期分配任务。项目简介：全聚星是由香港上市企业-中国创意集团斥巨资打造的国内首家艺人养成互动平台。我们以赵薇、佟大为等明星股东为支点、专业化的艺人培养机制为保障， 高品质的互动视频内容为跳板、为才艺新人提供全方位的培养、包装体系。全聚星积极探索符合国内业态发展需要的新型娱乐经济产业模式，汇聚互动综艺直播、明星直播、才艺直播等高品质互动视频内容，率先开启全民互动娱乐2.0浪潮。2015/09 – 2016/05理大师用户端和管理端责任描述：独立开发“理大师”app的用户端，负责整个项目的框架、逻辑处理以及各个模块的开发，地图定位 poi 搜索 导航，微信支付和支付宝支付，推送通知，配合后台和web前端交互处理h5界面，维护升级。项目简介：理大师以中医理疗推拿为核心的O2O健康理疗上门服务的平台。专注健康，贴心服务，以百年传承的中医养生医疗体系为核心，融合西医及美式整脊疗法先进的检测与健康管理方法，为用户提供定制化的名医大师健康理疗服务。2014/10 – 2015/09快停责任描述：快停App手机端的开发，根据需求进行iOS平台客户端软件的开发和维护,设计项目框架，实现界面展示与后台调试api完善项目功能，维护升级。项目简介：&nbsp;&nbsp;快停司机端:为车主提供便捷精准可靠的停车服务（精准定位，停车导航，智能计时，在线支付），为车主彻底解决城市出行中停车难的问题，同时为停车场提供智能引导，平台支付，高效管理，实现停车场效率与收益最优化.&nbsp;&nbsp;&nbsp;&nbsp; 教育经历2016/07 – 至今 郑州大学远程教育|计算机科学与技术|本科|非统招2013/09 – 2015/06河南广播电视大学|机械设计制造及其自动化|大专|统招语言能力英语 ：读写能力熟练| 听说能力良好]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo配合github搭建免费博客，绑定域名]]></title>
      <url>%2F2017-03-15-Hexo%E9%85%8D%E5%90%88github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%EF%BC%8C%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D.html</url>
      <content type="text"><![CDATA[出发点：有那么大的博客平台不用为什么自己搭建博客，说白了就是玩玩坚持写几篇博客然后就是装逼了呗。本篇文章在我的简书地址今天要讲的搭建博客教程很简单不需要什么钱当然有钱可以买虚拟机配个数据库可以玩wordpress搭建博客更简单，记得万网有活动几块钱就可以买个一年的虚拟机活动长期有可以看看，这里就不详细介绍了。言归正传，本篇博客说的是用github和 Hexo搭建一个免费的博客网站，搭建完看起来像这样 http://ws1227.github.io 如果有个人域名就可以类似这样http://wangsen.website/ 后边再介绍。 先说下需要的基本条件：安装Node（必须） 作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。提供一个mac版本的https://pan.baidu.com/s/1gf5NSyf 不用翻墙下载了安装Git（必须）作用：把本地的hexo内容提交到github上去. 安装Xcode就自带有Git，我就不多说了。没有的话可以去https://git-scm.com/downloads 下载申请GitHub（必须）作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。安装HexoNode和Git都安装好后，可执行如下命令安装hexo：1$ sudo npm install -g hexo创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：1hexo init好啦，至此，全部安装工作已经完成！因为Hexo编写的文章都是用 markdown语法写的 所以需要生成静态界面也就是Html网页。 生成静态页面继续在刚才的Blog目录下执行如下命令，生成静态页面 1hexo generate （hexo g 缩写也可以） 本地启动启动本地服务，进行文章预览调试，命令： 1hexo server （hexo s 缩写也可以） 开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了 ，可以更换个端口号 然后再执行 hexo s12hexo server -p 5000 #更改端口随意写hexo server -i 192.168.1.1 #自定义 IP运行成功后按Control+L可以停止 如果直接用Hexo s启动会提示错误 就是已经被占用了 所以正确的命令应该是12hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页上边算是搭建了一个本地的博客系统了 然后就是配置Git了用git就可以把博客移动到远程服务器访问类似我的博客地址http://ws1227.github.io配置Github建立Repository建立与你用户名对应的仓库，仓库名必须为【useame.github.io】如下图我的，固定写法 建立关联 打开Blog在本地/Users/wangsen/Blog，Blog是之前建Hexo的文件，有：12345678910Blog ｜ ｜－－ _config.yml ｜－－ node_modules ｜－－ public ｜－－ source ｜－－ db.json ｜－－ package.json ｜－－ scaffolds ｜－－ themes 现在我们需要打开_config.yml文件，来建立关联，命令： 如果终端不是在Blog目录就cd到该目录执行命令 1vim _config.yml 我建议用sublime翻到最下面，改成我这样子的，注意 : 后面要有个空格repository地址换成你自己的git地址1234deploy: type: git repository: https://github.com/ws1227/ws1227.github.io.git branch: master执行如下命令才能使用git部署1npm install hexo-deployer-git –save配置命令：作用就是把blog目录下的Public目录下的文件上传至git仓库1hexo deploy 然后再浏览器中输入就行了http://ws1227.github.io/，我的 github 的账户叫 ws1227 ,把这个改成你 github 的账户名就行了每次修改博客文件后都需要从新部署123hexo cleanhexo generatehexo deploy一些常用命令：http://www.jianshu.com/p/eb02029f7a81HEXO主题 如果你到了这里没有任何问题，那么恭喜你已经成功了，不过这才刚刚开始。当你成功的看到自己博客搭建好的那一刻又是激动又是失望，激动的是博客总算折腾出来了，失望的是，为何如此的丑。。。说实话Hexo默认的主题我不喜欢，如果你想换风格,Hexo的主题网上随便一搜也有很多。在此笔者使用的博客主题是Next.Pisces（国人写的）。https://github.com/iissnan/hexo-theme-next 作者很详细的使用文档域名绑定（第三步，可选）笔者是在万网买的域名（http://wangsen.website/）。 域名买好之后提交实名认证等，这些操作就不在赘述。域名购买地址。价格表：https://wanwang.aliyun.com/help/price.html?spm=5176.8076989.339865.8.yRl9gU选择自己喜欢又能接受价格的域名吧 域名是需要每年都付钱的，看清楚续费价格再下手。买完域名后进入域名管理后台添加解析,下图我添加解析后的。说下这个记录值就是ip地址得获取方式，打开终端ping下自己的git仓库 命令如下格式1ping ws1227.github.io看到如下数据，就看到这个ip地址了123456PING github.map.fastly.net (151.101.100.133): 56 data bytes64 bytes from 151.101.100.133: icmp_seq=0 ttl=50 time=105.119 msRequest timeout for icmp_seq 164 bytes from 151.101.100.133: icmp_seq=2 ttl=50 time=105.448 ms64 bytes from 151.101.100.133: icmp_seq=3 ttl=50 time=104.788 ms64 bytes from 151.101.100.133: icmp_seq=4 ttl=50 time=103.319 ms然后在你的本地站点目录里的source目录下添加一个CNAME文件，不带后缀，可以用终端切换到source目录下，执行命令如下1vim CNAME内容是域名地址不带www和http 就类似我的是 wangsen.website填写完了之后再重新部署到github pages上（部署简写命令hexo d -g)打开自己的博客尽情打开各种蹂躏吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017-03-15-hello-world.html</url>
      <content type="text"><![CDATA[新的一片天]]></content>
    </entry>

    
  
  
</search>
